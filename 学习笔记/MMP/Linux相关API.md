---
title: "[MMP] Linux相关API"
date: 2017-09-28 21:33:50
categories: [学习笔记, MMP]  
tags: [MMP,Linux,C++]
---
_这里记一些进程间通信（专注数据交换）和同步（操作同步和信号）的内容_

_这里不记录网络和文件部分，之后在其它文件记录。这里是原始笔记，结构有点不好，夹杂了一些其它内容，之后会把它们分到其它文件里。_  
# 进程
记了一些跟多进程无关的内容。  
## 创建
**fork**   
以父进程当前状态为基础创建一个子进程。  
linux中所有子进程都是由init直接或间接fork出来的。  

复制（写时复制）了几乎所有信息，包括执行位置，所以每个进程都会从fork的返回处继续执行。多线程只会复制当前线程状态信息，其它线程丢弃。  
子进程ppid会设置为父pid。  
父进程返回子进程pid，子进程返回0，错误-1。一般用switch/-1/0/default处理。  
在创建后其执行先后顺序是**不定**的。  
子进程可获得父进程所有fd副本（类似dup创建），并且共享文件偏移量，父进程打开的文件描述符在子进程也是打开的，文件描述符引用计数+1，父进程的用户根目录、当前工作目录等引用都会+1。  
pid不同，文件锁定不继承。  

注意在fork后可能会引发一些问题：
关于stdio缓冲，缓冲区是由进程控制的，fork时也会复制缓冲区。但是缓冲区的刷新（flush）策略（行缓冲、块缓冲）不同，可能会引发不同的执行结果，比如先printf后fork，有可能会在fork后得到两个输出，这就是因为缓冲区的刷新策略。  
要避免这类问题，需要在fork前用fflush刷新缓冲区或关闭缓冲功能。
用write不会产生这类问题，因为它将数据提交给内核缓冲区，fork无法复制，所以有可能会先于printf输出（因为要等刷新）。  


**execl、execlp、execle、execv、execvp、execve**  
运行指定程序替换当前进程，那些后缀表示不同的参数输入方式  
一般不返回（没必要），出错返回-1  
如果不出错，之后的代码都不会执行，被替换成指定的程序  
exec不会关闭原程序打开的文件描述符，除非文件描述符设置了FD\_CLOEXEC（socket SOCK\_CLOEXEC）  
exec会继承之前程序的环境变量，所以要修改就要在执行exec前改好  
fexecve 运行指定文件描述符的程序


运行进程时用exec可以将程序加载至内存并替换掉先前程序执行，进程id、父进程id优先级和用户、组都不变，其它都替换掉就跟刚才不是那个进程执行一样  
需要在不同程序间共享文件描述符，就需要fork再exec另一个程序
文件描述符是继承的  

一个用法是fork创建子进程然后子进程exec一个程序，这样就相当于运行一个其它程序作为子进程，
fork在现在采用了写时复制（以前不是，所以有一个vfork是为那时候准备的，但是这个函数不会判断创建子进程失败的问题），所以fork再exec实际上还是比较快的。  

**clone**  
它可以在进程创建期间提供更细致的操作，不过会有损可移植性。  
用于线程库的实现，它跟fork一样，但是在创建完后会去调用指定的函数。内部跟fork一样都是用do\_fork实现。
当函数返回时进程会退出。  
可以在创建的同时设置父子进程共享选项

<!-- exec fork 对进程属性的影响见UNIX系统编程手册 上 p505 pdf:p534 -->

## 终止
exit(会执行一些退出操作)/_exit（直接终止，貌似不会刷新缓冲区） 可以终止程序  
aexit 用来注册程序结束时运行的函数


## 监控子进程
**wait** 等待任一子进程终止，同时在参数返回该子进程的终止状态，可用某些宏（sys/wait.h）读取退出原因。如果调用时（之前）没有子进程终止则阻塞，如果调用时（之前）有子进程终止，则立即返回。  
错误-1 ECHILD。_一些书说会丢失某些退出信息。需要用非阻塞的函数来处理。_

**waitpid** 可用于等待指定子进程终止，可用WNOHANG选项设置非阻塞，未终止返回0，退出就返回pid，错误时会-1 ECHILD。可传入pid:-1参数等待任意子进程（表示法跟常用的一样）。  

**waitid** sys/wait.h 类似上面，不过设置是用另一种方法，提供更细的方式等待。

**wait3 wait4** 可以同时返回一些资源使用情况，不过这个函数返回的信息没什么价值。

<!--*子进程传递文件描述符给父进程*
Linux高性能服务器编程.pdf 283p 没仔细看
用socket_pair-->


## 僵尸孤儿
子进程结束时会保留一个基本数据结构等待父进程取信息，取完后才结束，这时**子进程**处于**僵尸状态**（在子进程早于父进程退出时）。该进程所保留的是内核进程表中的一条记录，包含一些进程信息。  
此时该进程无法用SIGKILL终止，确保父进程总是可以执行wait方法，注意一定要清掉僵尸进程，否则它会一直保留。  
如果父进程终止，子进程的父进程会被重新指派成init，init进程会周期等待子进程，这样确保它们不会成为僵尸进程（在子进程退出前子进程处于僵尸态）。  

一个wait只能等待一个子进程，如果创建了多个而只等待一次，将会出现n-1个僵尸子进程。对wait调用可以同步也可以异步。  

如果不想一直阻塞等待或连续调用waitpid，可以用信号来处理。  
子进程结束时它会给父进程发送**SIGCHLD**。  
注册处理函数，就不需要阻塞等待了。  
由于信号的一些特性，连续的SIGCHLD可能只能捕获一次，这时候需要在处理函数中写
```
// -1表示所有子进程
while(waitpid(-1,NULL,WNOHANG) > 0) continue;
```
规范未规定在未注册处理程序前，子程序终止是否会发送信号；所以要**先注册再生成子进程**。

另外在子进程停止时父进程也可能收到SIGCHLD，可以在sigaction设置时传入SA\_NOCLDSTOP，这样在子进程停止时就不会发出该信号。  

忽略终止的子进程
可以显式设置忽略SIGCHLD, 设置为 SIG_IGN 即可，但并不是所有系统都支持。此时系统会将终止的子进程立即删除，不转化为僵尸（此时用wait不会得到任何消息）。  
也可以设置sigaction的SA\_NOCLDWAIT，作用一样（但是貌似可以捕获信号）。


如果创建进程并立即等待终止，可以用system来创建进程


## 信息
```cpp
#include <unistd.h> 
```
**getpid**
取得当前进程id  
进程pid上限32768（32位），超过就重置到300开始递增，64位很大，不用担心。  

**getppid**  
取父进程id  
当父进程终止，init就会接管孤儿进程，所以这个情况会得到1（init的pid）。可以用pstree查看进程树。
可以读取/proc/PID/status PPid字段获取父进程id  


检查进程存在
可以用kill发空信号（0）检查，如果发送失败且ESRCH错误，表示进程不存在。但是有可能该进程是僵尸或者被其它进程替代，所以为了保证正确性需要用其它方式检查。  
可以用wait监视子进程；或者用信号量或排它锁，当检查时能获取到锁时表明进程终止；或者用管道，当接收到EOF时表示进程退出。  



## 组、会话、作业控制
进程组由一个或多个共享同一进程组标识符的进程组成。
进程组id跟创建组的进程id相等。  

会话是一组进程组的集合，子进程会继承父进程sid。  
会话中所有进程共享单个控制终端，终端会在首进程首次打开一个终端设备时建立。任一时刻，会话中的其中一个进程组会成为前台进程组，其它为后台进程组，只有前台组可以从终端读取输入。  

作业控制就是shell中的bg fg jobs相关功能。  
当进程变为孤儿时，会与终端断开连接，如果进程组变为孤儿进程组（每个成员的父进程是组成员或是其它组会话的成员），而且有停止执行的成员时，系统会发送SIGHUP和SIGCONT给进程组

函数|介绍
---|---
getpgrp|取pgid
setpgrp|设置指定pid的pgid，0表示自身pid（pgid:0表示设置pgid为自身pid）
getsid|主要用于诊断，用处不大
setsid|创建新会话，调用进程会成为新会话的首进程和会话中新进程组的首进程。id都会设置与pid相等。
ctermid|获取终端路径名
tcgetpgrp<br/>tcsetpgrp|获取或修改一个终端的进程组

## 优先级
-20~19  高~低
特权进程才能调高自己或别人的优先级，否则只能降低自己的优先级（现在可以在软限制范围RLIMIT_NICE内提升）  
nice值会继承。  

getpriority setpriority 用于设置或获取

**实时调度**
可以提供足够的性能和响应度，实时优先级范围1~99（低~高）  
优先选择优先级高的，然后按策略选择：
SCHED_RR 循环，每个进程使用固定长度时间片，可以放弃或被高优先级抢占
SCHED_FIFO 得到控制权后会一直执行，直到放弃或被高优先级抢占

非实时的策略（不过要用实时调度的api来设置）：
SCHED\_BATCH 类似SCHED\_OTHER 用于进程批量执行，前者会减少频繁被唤醒的任务的调度
SCHED_IDLE 非常低的优先级，只在空闲时调度

sched\_get\_priority\_min sched\_get\_priority\_max 用于获取指定策略的优先级

sched\_setscheduler 修改策略和优先级  
sched\_setparam 修改调度策略，不修改优先级

获取就是改为get，略  

sched\_yield 释放cpu

sched\_rr\_get\_interval 取得rr策略的时间片长度


## 亲和力
设置亲和力可以避免cache数据失效带来的性能影响；如果多个进程或线程访问同样的数据，可以将它们限制到同一个cpu上提升性能（提高命中率）；对于某些实时程序，可以将它限制到其中一个cpu，其它进程限制到其它cpu上。  

sched\_setaffinity sched\_getaffinity 用于设置和获取，pid:0表示自身  

注意这是一个线程级特性，pid:0表示调用线程，可以设置gettid返回的值来设置相应线程亲和性。  

设置结构用以下函数(宏)操作：  
CPU\_ZERO（初始化） CPU\_SET（添加cpu） CPU\_CLR（删除cpu） CPU\_ISSET（判断是否设置）  
cpu从0开始编号，如果编号不匹配setaffinity会返回EINVAL  

## 资源
可以用getrusage监控自己和子进程已经用掉的资源，有cpu时间、内存占用和页错误次数等

可用get[set]rlimit 读取和修改资源限制，可以设置的是RLIMIT\_XXX宏定义，有内存、cpu、资源数量等。  
注意跟在shell下的单位不同，这里是字节单位，shell的是kb  


## 守护进程
运行在后台的进程，不会连接到任何控制终端，名称通常以d结尾（如shhd）  
必须符合：是init子进程，不得连接到一个终端

注意特定的daemon会作为内核线程运行，在用ps列出时会用[]标识

使进程变成daemon的步骤为（一些书会有多一些步骤，比如会在setsid后再fork确保进程永远不会重新请求一个终端）：
* 调用fork，父进程exit
* 调用setsid，替子进程创建一个新的进程组以及会话，这两者都会以daemon作为首领，这样可以确保该进程不会被关联到控制终端
* 用chdir将工作目录换到根目录，主要是防止保留之前的工作目录
* 关闭所有文件描述符，文件描述符会继承的，要关干净
* 打开文件描述符0、1、2（stdin、stdout、err）并将它们重定向到/dev/null
* 会用umask把守护进程的umask设置为0，因为它会继承，而且会潜在影响文件创建

setid创建新会话和建立一个新进程组，然后守护进程会成为新会话领导以及进程组领导，并保证新会话没有控制中端，如果调用进程是进程组领导则调用失败，成功返回新会话id，失败-1

有函数**daemon**可以简化这些步骤
会返回-1错误，成功返回0，父进程会被结束

通常daemon在系统关闭时终止，在系统终止时daemon会收到SIGTERM，可以捕获来做一些清理工作；在发完SIGTERM 5s后，会发SIGKILL，所以需要快速的完成清理。  

由于守护需要持续运行，所以有时候需要在不重启进程的情况下修改配置或操作某些文件，可以设置SIGHUP（因为没有终端所以系统永远不会向进程发这个信号）来重新初始化进程

## 权限
需要了解的函数：
getuid 取当前用户id   
geteuid 取有效用户id（可使用资源的用户id，这个是因为+s的程序运行时会把有效用户id设置成属主或组id而使程序获得高权限）  
getgid 取组id  
set的略

如果在程序中不需要使用到权限就不使用（以最小权限操作），需要权限才能完成的功能可以拆分到其它只执行单个任务的程序里。  

如果需要允许用户修改一个它没有写权限的文件，可以将文件属组和进程有效组都设置为一个专用组，这样可以避免程序被破坏时造成的损失。  

在程序开始时可以禁用某些权限，如果不需要可以删除，如果需要就在使用时临时获取权限执行。通过geteuid seteuid实现。  
需要临时降低权限用 seteuid(getuid()) ，但是在永久删除权限时需要重新获取权限，然后调用 setreuid(getuid(),getuid())，组的就用组相关的函数。  
书中建议在设置后再验证一次id，因为可能会由于系统的某些设置而修改失败。  

在程序执行其它程序的时候需要注意删除权限。并且注意特权程序不要直接或间接的执行shell和其它不受限的解释器。并且注意关掉用不到的fd。  

安全程序需要避免产生核心dump，可用setrlimit将RLIMIT\_CORE设置为0来防止其创建。  

注意需要确保进程永远无法创建（用umask）公共可写的文件的值，否则可能会被修改。另外不要信任环境列表，对所有用户输入内容做防御性地处理，防止出现缓冲区溢出等问题。  

## 能力
传统的权限模型是all-or-nothing，使用能力模型可以限制权限。  
**进程能力**
内核会为每个进程维护3个能力集（位掩码）：  
* 许可的：可使用，如果删除将无法重新获取（除非它执行再次授予该能力的程序）
* 有效的：内核会用这些能力对进程执行权限进行检测，可以临时禁用该能力，之后还可以还原
* 可继承的：执行程序时可以将这些权限带入许可集中

**文件能力**
如果文件具有相关能力集，它会被用来确定执行这个文件的进程的能力。  
* 许可的：在exec调用中会将能力添加到进程的许可集里，不管既有能力是什么
* 有效的：只有1位，启用后，在进程新许可集启用的能力在有效集里也会启用，否则是空的
* 可继承的：取掩码来确定在执行exec后进程的许可集中启用的能力集


<!--能力定义 CAP\_XXX  UNIX系统编程手册 下 p655 pdf98有表-->

能力用setcap getcap操作（编程中应该避免使用这两个系统调用）。  
可以使用libcap库进行编程操作。  
cap\_get\_proc 获取能力集副本  
cap\_set\_flag 更新副本  
cap\_set\_proc 提交副本，传回内核以修改进程能力  
cap\_free 释放get\_proc分配的结构  

<!--没记完 pdf108-->


# 线程
这里主要记录的是pthread线程。  
这里会**记录得比较少**，因为大部分情况都可以直接用stl或boost。  
多线程主要是为了更方便的共享信息，多进程必须用一些进程间通信方式来进行信息交换。在多线程中使用信号时需要小心设计（一些书建议不要在多线程程序中使用信号机制，因为会引起混乱）。  

书里提到linux用clone实现线程（估计是设置了某些共享参数）

在多线程中errno是tls的。
所有pthread函数返回0表示成功，**正值**（errno值）表示失败。
编译时要加-pthread。
线程栈2M(32),32M(64)

注意在多线程程序中fork，子进程不会复制其它线程，只是复制调用fork的线程，而且锁也是锁住的，锁可能是其它线程锁的所以这时fork出来可能会有问题  
这时要用pthread_atfork  

每个线程都可以设置信号掩码  
pthread_sigmask  

## 操作

函数|介绍
---|---
pthread\_create|创建，在函数返回前会将tid（pthread\_t格式）保存到第一个参数中；可以在创建时为线程设置某些属性，可传入null
pthread\_exit|终止
pthread\_self|取自身tid
pthread\_equal|检查两个tid是否相等
pthread\_join|等待指定线程停止
pthread\_detach|分离线程，如果不关心返回状态可以使用，此时无法再join
pthread\_cancel|取消线程，执行后立即返回，不会等待线程退出
pthread\_setcancelstate<br/>pthread\_setcanceltype|对取消请求响应过程加以控制
pthread\_testcancel|检查可取消性
pthread\_cleanup\_push<br/>pthread\_cleanup\_pop|设置清理函数，在线程取消时会执行这些函数来回收一些资源


**线程属性**
create时传入的参数用这些函数构造：
pthread\_attr\_init
pthread\_attr\_setdetachstate
...

**call\_once**
pthread\_once 跟stl一样，不过flag为pthread\_once\_t

**tls**
一般用cpp的关键字，这组函数用kv的方式取得相应的内容（注意各个线程用的是相同的key，可以取得线程特有value）
pthread\_key\_create  
pthread\_key\_setspecific  
pthread\_key\_getspecific  



# 互斥量

**初始化**  
pthread\_mutex\_t mtx = PTHREAD\_MUTEX\_INITIALIZER

或者可以动态初始化，用：
pthread\_mutex\_init  

可以设置一些错误检查和死锁检测功能，并且可以设置为可递归

**操作**  
pthread\_mutex\_lock  
pthread\_mutex\_unlock  
pthread\_mutex\_trylock  
pthread\_mutex\_timedlock  
pthread\_mutex\_destory

# 条件变量
**初始化**
pthread\_count\_t cond = PTHREAD\_COND\_INITIALIZER
pthread\_cond\_init  

**操作**
跟stl相同，也需要mtx，但是如果需要条件检查，需要自己写（函数不提供检查功能）   
pthread\_cond\_signal  
pthread\_cond\_broadcast  
pthread\_cond\_wait  
pthread\_cond\_timedwait  
pthread\_cond\_destory  



# 原子
因为用stl更方便，没有记录相关内容，待补充。  

# 管道/FIFO
在传送数据时，会将数据复制到内核中的管道缓冲区中，读取时再从该位置读取出来。  
FIFO可以用于任意进程间的通信。  
都是单向数据流，无消息边界，可用流socket的方式来读取数据。 

## 管道
pipe/pipe2（带选项） 创建，传入数组，调用成功后会在数组中填入管道读写端，使用read write读写。  
如果多个进程写入同一个管道，如果同一时刻写入的数据量小于PIPE_BUF（至少512字节，不同系统实现不同）时，可以确保写入操作是原子的。  
管道缓冲区存储能力有限（65535，可修改），如果满了，后续操作会被阻塞到有空位为止。  
fork后一般会把一个方向的fd关掉，只保留一个方向；如果同时使用会造成竞争，而且关闭后，在写入结束关闭fd时，读取端可以看到文件结束；如果需要双向通信就需要再创建一个管道，但是要注意在阻塞等待数据时可能会死锁。  
当进程试图写入数据但没有读取fd打开时，内核会向写入进程发送SIGPIPE，默认会终止掉进程，可以捕获或忽略，这样可以从write处收到EPIPE错误。  
如果写操作大于阈值PIPE_BUF,返回值是管道中目前数据的字节数，如果小于就返回现有数据字节数（管道数据量小于请求量）或者返回请求数（管道数据量大于请求数据量）
如果只写不读，管道会被充满并阻塞写操作；销毁管道后未读取数据都会丢失。   
书中提供了一种将管道用于同步的方法，就是父进程read，子进程做完动作后就关掉写fd，这样在fd被完全关掉后父进程就可以执行其它操作。  



## FIFO
命名管道，它在文件系统中拥有一个名称，打开方式跟打开一个文件一样。可用于非相关进程通信。  
在所有fd关闭后，未读取数据会被丢弃。在shell中用mkfifo创建，程序中也用同名函数创建。  
注意以读方式（O\_RDONLY）open时，会阻塞直到有进程以写方式（O\_WRONLY）打开为止。可以指定O\_RDWR绕过阻塞行为，但是无法使用fd进行读取和写入，如果需要避免阻塞，可以指定O\_NONBLOCK标记。  
注意在以读取非阻塞方式打开时，如果没有以写方式打开，也会返回成功，因为此时读取时不会返回数据；但是以写非阻塞方式打开，没有以读方式打开时，会返回ENXIO错误。  
可以用fcntl修改阻塞状态。  
非阻塞操作跟socket一样，在其它笔记写。  

# System V IPC
在get时给定key，如果存在就返回该对象，不存在就创建后返回。  
如果用IPC\_CREAT打开，不存在（存在但是设置为IPC\_PRIVATE也一样）时会ENOENT错误。  
可用IPC\_EXCL确保进程是该对象的创建者，如果已存在就会返回EEXIST错误。  
可用ctl操作的IPC\_RMID删除对象，有一些对象是立即删除，有一些会等到所有进程都释放才删除。  
在创建时可以将**IPC\_PRIVATE**常量作为key的值，这会导致每个调用会创建一个全新的IPC对象，从而确保拥有唯一key，但此时使用时需要用某种机制（比如fork）获得这个对象的fd。可以用ftok函数生成一个key，需要使用一个可以应用stat的既有文件路径，它是用inode来生成key，而且要注意可能会生成同样的key（可能性很小）。  

如果进程是特权进程，所有权限都会被赋予IPC对象；如果有效用户id跟对象所有者或创建者匹配，则将owner的权限赋予进程；如果有效用户id或任意辅助组id与对象所有者组或创建者组id匹配，则将对象group的权限赋予进程；否则将对象的other赋予进程。  

在get时会检查参数中指定的权限（有S\_IRUSR、S\_IWUSR、S\_IRGRP等）跟对象权限是否匹配，不匹配会返回EACCESS。  

ipcs可以获得系统上ipc对象的信息，也可用/proc/sysvipc查看。  
可用ipcrm删除ipc对象。  


## 消息队列
sys/msg.h
一次读取一个消息，消息带有类型标识，可以根据类型来读取消息。  
msgget 用于打开或创建消息队列
msgsnd msgrcv 用于执行消息队列上的io，第一个参数是消息队列标识符，第二个是接收数据指针。数据格式第一部分用long标识数据类型，其它任意。  

可自定义消息大小，注意不能大于MSGMAX。在发送消息时需要将数据类型标识（mtype）设置为大于0的值，发送时填入的大小字段是除了类型标识外的大小（数据mtext大小，可以不必是完整长度），flag参数只有IPC\_NOWAIT用于非阻塞。  
在接收时需要传入同样的类型的缓冲区（需要带long类型标识），并填入数据字段最大可用空间（缓冲大小），如果队列中的消息大小超过这个大小，将会产生E2BIG错误。  
可以传入类型标识（mtype）参数选择消息，如果==0，就从第一条读；>0 就从第一条类型等于这个值的读，可以用pid标识类型，这样就可以多个进程用同一个队列；<0 会把这个队列当做优先队列，取队列中mtype最小并且小于或等于参数绝对值的第一条。  

msgctl 控制操作  
IPC\_RMID 立即删除，调用会返回EIDRM错误。   
IPC\_STAT 将管理的msqid\_ds结构（内容基本上是一些状态信息）副本放到缓冲区（buf参数）中  
IPC\_SET 使用缓冲区提供的值更新关联的msqid\_ds结构  

系统会对消息队列有一些限制：  
MSGMNI 能创建消息队列标识符的数量  
MSGMAX 最多可写入的字节数  
MSGMNB 最多保存的字节数  
MSGTQL 系统中所有消息队列的消息总数  
MSGPOOL 系统中所有消息队列数据的缓冲池大小  


在使用时可以多进程共用一个消息队列，也可以为每个方向设置一个队列。  
消息队列是用消息队列标识符引用的，而不是fd，所以无法用于epoll。  
书中不建议使用System V消息队列，可用POSIX消息队列替代。  


## 信号量
sys/sem.h
其值被限制>=0，试图减小到0以下会被阻塞。  
semget  
创建或打开信号量集（注意这是一个集合），如果用它创建，可以用参数设定初始信号量数量，否则该参数必须小于或等于集合大小  

semctl  
第二个参数（信号量编号）按需使用  
用SETVAL(可以指定下标)或SETALL初始化信号量，IPC\_RMID删除，GETALL/GETVAL可以获得信号量值。可以用GETPID获取上一个在该信号量上执行semop的进程的pid，GETNCNT 等待信号量增长的进程数，GETZCNT 等待信号量为0的进程数  

信号量必须用SETVAL/SETALL设置初始值

可用IPC\_STAT IPC\_SET 获取或设置关联数据结构

semop  
操作信号量值  
需要传入操作数组和操作数组的大小。  

```cpp
ushort sem_num; // 标识要操作的信号量编号
short sem_op;  // 大于0就加，小于0就减，等于0就检查是否为0，否则阻塞
short sem_flag; // IPC_NOWAIT SEM_UNDO（内核记录信号量操作的效果，在进程终止时撤销掉这个操作，不过这个操作需要配合回复资源，否则没有实际用处，另外撤销的值可能大于当前信号量，此时会带来一些问题）
```

semtimedop  
带有超时机制的信号量操作

信号量也有类似消息队列那样的限制，略。  
书中同样推荐用POSIX信号量代替使用。  

## 共享内存
分到统一分类里  

# POSIX IPC
共享内存和消息队列名最大长度为NAME\_MAX(255)字节，信号量少4，因为实现会附加前缀`sem.`。名字可以以`/`开头。  
每一种机制都有open调用。除用munmap解内存映射，其它有相应的close调用。    

flag可用O\_CREAT O\_EXCL，功能类似前面提到的。  

POSIX IPC 是引用计数的，在所有进程关闭该对象后会销毁。  
建议用POSIX IPC代替System V IPC   

## 消息队列
引用计数，消息按优先级排序，提供通知机制。  
内部被实现成虚拟文件系统中的inode。  
可用 `mount -t mqueue 任意 目标` 挂载它  


mq_open  
创建或打开队列，返回消息队列描述符  
可以通过参数mq_attr设置消息队列非阻塞、队列大小()>0)、消息大小(>0)等  

flags:  
O_CREAT  
O_EXCL  
O_RDONLY  
O_WRONLY  
O_RDWR  
O_NONBLOCK  

fork后子进程会继承描述符，在进程终止或exec，描述符会被关闭。

mq_send  
向队列写入
msg\_len必须小于等于mq\_msgsize，可以为0  
msg_prio是优先级（0最低，最高至少32，linux上到32768），如果不需要消息优先级，设置为0即可  
如果队列满会阻塞，非阻塞会返回EAGAIN  


mq_receive  
读，会将数据放到msg_ptr缓冲区，从优先级最高，存在时间最长的开始读。  空队列会阻塞

mq\_timedsend mq\_timedrecive  
超时机制读写

mq_close  
关闭，会删除通知注册，关闭消息队列并不会删除它，删除要用unlink

mq_unlink  
删除消息队列名，并在所有进程关闭队列时清除，如果其它进程都关闭会立即删除。  

mq_getattr  
获取消息队列特性

mq_setattr  
设置特性，但只能修改阻塞与否，不能改大小（在创建时已固定）  

mq_notify  
消息通知（推模型）  
任何时刻只有一个进程能注册接收通知，后续注册会失败。  
如果注册时队列非空，只有在队列清空后再来消息时才通知，因为通知时机是空到非空。  
当向进程发送通知后会**删除**注册信息，之后其它进程可以注册。  
传入null参数注销注册。  


## 信号量
sem_open   
打开或创建信号量，创建时会初始化

sem\_post sem\_wait sem\_trywait  
递增递减信号量
到0时wait会阻塞  

sem_getvalue   
获取信号量当前值  

sem_close  
删除信号量与进程的关联

sem_unlink  
删除信号量名，在所有进程关闭该信号量时删除 

sem_init  
用于初始化未名信号量，可以设置是在线程间共享还是进程间共享，会放到sem_t中    

sem_destory  
销毁未名信号量  


## 共享内存
分到统一分类里  




# 共享内存
内核将进程中的页表条目指向同一个ram分页来实现，不需要系统调用和在内核及用户内存之间传输数据，所以速度很快。  
放入共享内存中的数据对所有共享这块内存的进程可见。在使用时需要配合其它同步机制。

## System V 共享内存
sys/shm.h  
shmget  
创建或取得共享内存段，如果没有就按大小创建，有就忽略这个大小，但是大小必须小于或等于已有段的大小。
flag除了之前的可用外，还有SHM\_HUGETLB 巨页共享内存段（MB以上的分页大小），SHM\_NORESERVE 跟在mmap中作用一样    

shmat  
使该内存段成为进程虚拟内存的一部分，需要使用返回的addr值  
可以指定目标地址（跟win的一样），但是不推荐，一般用null  
有这些flag（0是读写）：  
SHM\_RDONLY 附加只读段  
SHM\_REMAP 替换shmaddr既有映射  
SHM\_RND 将shmaddr对齐到SHMLBA大小的倍数  

默认会映射到栈和堆之间未分配的内存地址空间中（从0x400000000开始）  
如果需要在共享内存空间中存储指针，需要使用偏移指针（boost中有例子）  

shmdt  
分离共享内存段  

shmctl 
删除（IPC\_RMID）共享内存段（只需要执行一次。此时仍可以附加段，但是这个行为不可移植），只有所有的都分离后才会被真正销毁  

共享内存段可以锁进RAM中，这样它就不会被交换出去。可用SHM\_LOCK SHM\_UNLOCK 锁定和解锁，前提是有效用户id跟创建者用户id一致。在设置时并不会马上锁入内存，而是在这些分页被访问时一个个地锁入。  

相关取关联数据结构和资源限制的内容跟前面一样，略。   

## 内存映射
使用mmap可在进程虚拟地址空间创建一个新的内存映射。  
可以创建两种类型的映射：文件、匿名。  
可以通过映射同一个文件的同一个区域实现映射共享，也可以通过fork取得映射副本实现共享。  

当多个进程共享的页面相同时，如果是用私有标志（MAP\_PRIVATE）映射(写时复制)的，则对映射内容修改**对其它进程不可见**，并且改动也不会更新到文件上；如果以共享方式（MAP\_SHARED），修改会对其他进程可见，并且会对文件造成改动。

mmap  
创建映射，可以指定映射位置，错误时返回MAP\_FAILED（-1）。需要指定映射大小和保护位（prot: PROT\_NONE（无法访问） READ WRITE（需要配合read使用，不能用只写标识） EXEC），flag参数是设置私有还是共享（MAP\_PRIVATE MAP\_SHARED）的。fd和offset（必须是分页大小倍数）是用于文件映射的，匿名映射会忽略它。  

会按页面大小整数倍映射，用sysconf（unistd.h）可以取得页面大小，或者用getpagesize或用宏PAGE_SIZE更简单  

其它的flag有：  
MAP\_ANONYMOUS 创建匿名映射  
MAP\_FIXED 原样解释addr参数  
MAP\_LOCKED 锁入内存  
MAP\_HUGETLB 巨页  
MAP\_NORESERVE 控制交换空间预留，默认映射使用稀疏矩阵的方式，使用这个会预留足够的空间，防止因空间不足而引起程序退出（由OOM(out-of-memory)代码发送SIGKILL信号）    
MAP\_POPULATE 填充映射的分页  
MAP\_UNINITIALIZED 不清除匿名映射  

munmap  
解除该区域的映射，可以解除整个空间，也可以解除一部分，如果该区域不存在映射，也返回成功（不执行任何操作）。  
当结束进程或exec后映射会被自动解除。  

mprotect  
可以修改保护位，跟win的差不多


**文件映射**  
在mmap后可以关闭fd，这不会有任何影响。映射的分页会在首次被访问时被映射进内存。  
对映射内容的变更都会自动反映到文件上。可以减少read write造成的内存传输和缓冲区消耗，提高性能。  
试图访问映射结尾外的字节会产生SIGSEGV信号，这会打出core dump并终止进程。如果映射大于文件结尾，这部分内存会被初始化为0，对它的修改不会反映到文件中，并且不会跟其它进程共享。    


在修改映射内容后，内核会自动将变更写入底层文件中，但是不保证这个同步操作的发生时机，所以提供 msync 用于同步操作。可以使用MS\_SYNC MS\_ASYNC设置同步或异步操作。可以带MS\_INVALIDATE 这样可以在其它进程的更新在区域中可见。    

可用remap\_file\_pages创建非线性映射

mmap绝对不会返回0，失败时会返回MAP_FAILED  
打开同一个文件，使用MAP_ANONYMOUS可以实现父子进程匿名内存共享
或者使用shm\_open创建或打开一个共享内存对象，这个会返回一个文件描述符，可供mmap使用，用完后用shm\_unlink删除，如果使用了这套函数，需要指定链接选项-lrt  

**匿名映射**  
使用MAP\_ANONYMOUS并且fd:-1，或者映射/dev/zero。  
_书中说glibc的malloc使用MAP\_PRIVATE分配大于阈值的内存块_  

可以用mremap来修改映射大小，但是这个操作不可移植。  

## POSIX 共享内存
shm_open  
创建或打开，返回的fd带FD\_CLOEXEC特性，初始长度为0   
创建后传入mmap使用（历史原因），跟open区别是不需要创建文件。  
在调用mmap之前需要用ftruncate扩大或搜索该对象  
可用fchmod fchown修改共享内存对象权限和所有权  

shm_unlink  
删除，否则会持续存在直到被删除或系统重启  
删除名字不会影响既有映射，但会阻止后续用open打开对象，一旦解除映射，对象就会被删除  

# 文件同步  
文件锁，配合stdio使用时需要小心（因为缓冲区刷新时机），一般用read write取代stdio来执行文件io  

加锁方式：  
* 劝告式: 默认，进程可以忽略掉这个锁，这需要所有进程配合使用  
* 强制式: 系统强制检查io  

flock  
用于加锁（整个文件，劝告式），传入fd，flag有：  
LOCK_SH 共享锁  
LOCK_EX 互斥锁  
LOCK_UN 解锁  
LOCK_NB 非阻塞锁，锁互斥时会阻塞，使用这个不阻塞并返回EWOULDBLOCK错误  

锁是与打开的文件描述相关联的，这样在fd被复制时会引用**同一个**文件锁（fork后会使用同一个锁），如果不显式解锁，当所有描述符副本关闭后这个锁才会被释放  


fcntl  
可用F\_SETLK（锁不兼容会调用失败）、F\_SETLKW（锁不兼容会阻塞）、F\_GETLK（检查锁）来进行操作。  
可设置文件一段范围的锁（劝告式）  
此时需要传入flock结构，带有flag：  
F\_RDLCK、F\_WRLCK、F\_UNLCK

如果要使用强制式加锁，需要开启set-group-ID并关闭group-execute来完成。  

# 虚拟内存操作

mprotect 修改内存保护标识。flag用的是 PROT\_ READ WRITE EXEC NONE  
**内存锁**  
将虚拟内存的部分或全部锁进内存防止被交换出去，这样可以提高性能，还可以避免敏感数据泄露（分页被写入硬盘，但是笔记本在挂起时是不管是否有锁都会存储到硬盘的）。  
特权进程能锁住的内存数量无限制，非特权能锁住的上限由软限制RLIMIT\_MEMLOCK定义（以分页为单位，默认8个分页（32768 Byte /x32））。  
这个限制能影响mlock、mlockall、mmap、shmctl操作  

使用mlock、munlock为内存区域加解锁，建议addr对齐分页大小，并且会锁住整个分页。  
可以用mlockall或munlockall来给进程占据的所有内存加解锁。  
锁行为不会叠加。  

可以用mincore来确定内存驻留性。  

**建议内存使用模式**  
madvise 可以通知内核相应地址的内存范围可能的使用情况来提升程序性能。  
flags(MADV\_开头)： 
NORMAL 分页以簇的形式传输，会导致一些预先读和事后读。  
RANDOM 分页会被随机访问，因此内核每次读取的数据量尽可能少。  
SEQUENTIAL 分页只会被访问一次，并且是顺序访问，因此内核可以激进地预读，并且访问后将其释放。  
WILLNEED 预读分页以备将来之需  
DONTNEED 在需要时交换出去  
DONTFORK  
DOFORK  
REMOVE  
SOFT_OFFLINE  
MERGEABLE  
UNMERGEABLE  


# 信号
因为信号编程比较繁杂，并且没有排队处理可能会丢失信息，使用中还会面临各种问题，携带的信息量也有限，所以很少将信号用于进程间通信。  
可以用man 7 signal 得到帮助
## 类型和默认行为


信号 | 行为
---------|----------
 SIGABRT/6 | 当调用abort函数时，系统就向进程发送。<br/>默认终止进程并产生核心转储文件（用于调试）。
 SIGALRM/14|alarm或settimer的实时定时器到期，内核产生。
 SIGBUS/7|发生某种内存访问错误。比如当用mmap时，访问地址超出结尾就会引发
 SIGCHILD/17 <br/> SIGCLD|子进程终止，内核会向父进程发送。当某一子进程因为收到信号停止或恢复时也可能发送。
 SIGCONT/18|发送给已停止的进程，使它恢复运行，非停止时忽略。
SIGEMT|依赖于实现的硬件错误
SIGFPE/8|算术错误，比如除0
SIGHUP/1|终端断开（挂机）
SIGILL/4|执行非法机器指令
SIGINFO|按Ctl+T产生，用于获取前台进程组状态信息
SIGINT/2|Ctl+C，用于终止进程
SIGIO/29 <br/> SIGPOLL|fcntl设置在打开某些特定类型fd时产生
SIGIOT<br/>SIGABRT|发生由实现定义的硬件错误
SIGKILL/9|终止进程，无法将其阻塞、忽略或捕获
SIGLOST|Linux未使用，UNIX才用
SIGPIPE/13|向管道写入信息
SIGPROF/27|由settimer设置的性能分析定时器过期时内核产生。
SIGPWR/30|电源故障，电量将耗尽
SIGQUIT/3|Ctl+\，终止进程并产生核心转储文件
SIGSEGV/11|内存引用无效
SIGSTKFLT/16|协处理器栈错误，Linux未使用
SIGSTOP/19|停止进程，无法阻止该信号
SIGSYS/31|发起的系统调用有误
SIGTERM/15|终止进程的标准信号
SIGTRAP/5|端点调试
SIGTSTP/20|Ctl+z，挂起
SIGTTIN/21|默认停止进程，在shell下运行时，后台进程组试图对终端read时，终端驱动程序向该进程组发送此信号
SIGTTOU/22|类似上面，但是是write
SIGURG/23|套接字上存在紧急数据
SIGVTALRM/26|settimer设置的虚拟定时器（根据使用的cpu时间定时）到期，内核产生
SIGWINCH/28|终端窗口尺寸发生变化
SIGXCPU/24|cpu时间超出对应资源限制
SIGXFSZ/25|当进程试图增大文件突破对进程文件大小的资源限制

可以用strsignal打印信号说明

## 使用
用signal和sigaction（首选）来设置。  
signal 关联处理信号的函数,@1:信号，@2:回调（void(int sig)），@ret:旧的回调,会替换掉旧的回调；旧函数不建议使用  
调用处理函数后会跳回原本程序位置继续执行  
signal在设置时返回旧处理函数指针，sigaction不需要设置就可以获得当前处理函数指针。  

sigaction 取代signal，@1信号，@2信号状态（在里面设置回调），@3返回旧状态  
要用sigemptyset清空mask  

当信号来时，内核会打断主程序流程，并代表进程来调用（似乎有不同的调用栈）处理程序，当返回时会从打断的位置恢复执行。  

发送信号用 kill（pid>0 指定pid，pid==0 自身和同组进程，pid<-1 组id为|pid|的进程组，pid==-1 所有进程除了init和自身）、raise（向自身发送）、killpg（向某进程组所有成员发送）。
杀死pid要发SIGKILL（默认SIGTERM）  
如果发0（空信号），kill只会执行错误检查，看是否可以像目标进程发送信号，可以用这个来检测特定pid是否存在，如果发送失败表示不存在  


当需要使用一组信号时可以用信号集。  
sigemptyset  
sigfillset  
sigaddset  
sigdelset  
sigismember  
sigisemptyset  
sigorset  
sigandset  

sigprocmask 设置掩码阻挡信号

sigaction 跟signal差不多，功能更强大

sigqueue 同kill，但会排入队列

可用pthread_sigmask、sigprocmask设置信号掩码，可阻塞其信号传递，直到解除阻塞，但是只表明信号是否发生，而未表明发生次数（貌似内部是用置位设置而不是用队列管理）。

可用pause暂停进程，直到有信号。
pause 让进程进入休眠状态直到收到信号，如果不处理信号则会终止进程,总是返回-1，如果触发处理函数，则处理在返回前执行  

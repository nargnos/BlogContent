---
title: "[模式] 对象交互、控制"
date: 2017-09-17 15:20:52
tags: 模式
categories: [学习笔记,模式]
description: 对象交互、控制、状态
---
# 应用控制
## 页面控制器（Page Controller）
### 作用
在做视图的控制器时，如果为每种类型客户请求提供一个单独的控制器会导致控制器实现复杂化，而且会造成一些功能重复。
可以为应用的用户界面中每个视图引入一个页面控制器以控制视图上发出的所有请求的执行。

为基于表单的用户界面中每个表单引入一个清晰的入口点，它将每个表单发出的服务请求的处理与执行联合起来。  
### 概念
页面控制器从请求参数中提取消息并转换成对应用组件的具体请求。
如果有实现策略上的差别，可以配合模板方法或者策略模式来实现。
好像指的是用同样的控制器类型来管理多个页面。

## 前端控制器（Front Controller）
### 作用
网络应用在处理请求时经常执行一些相似操作（比如在执行动作之前或之后进行授权和记录日志），根据当前的情况为特定的用户显示特定视图。如果在每个控制器都实现一套这个功能会出现很多重复代码。
这时候需要引入前端控制器，负责发布应用的功能，并将客户端的服务请求转换成具体的可以在应用组件上调用的请求。  
为应用建立一个唯一的入口，它将由用户界面发出的服务请求的处理和执行联合起来。  
### 概念
用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。
所有的客户端请求都通过它进行分派（分发），通过从客户端请求参数中提取信息等方式将请求转换成应用组件上的具体请求。（类似中介者的行为）

### 缺点
有单点失败问题。  
当多个客户请求同时到达时可能会造成性能瓶颈。


## 应用控制器（Application Controller）
### 作用
应用有不同的工作流或逻辑，如果将这些逻辑放到视图控制器中，会使界面代码和专属某个应用的工作流逻辑混在一起。  
将应用的工作流单独封装到一个应用控制器中，用户界面使用它来决定调用应用逻辑中哪个动作，以及动作执行完后显示那个视图。
将用户界面的导航和应用的工作流控制分开，它从应用的用户界面收到服务请求，根据当前的工作流状态确定调用哪项服务功能，然后根据服务的执行情况将相应的视图展示在用户界面上。
### 概念
为用户界面元素提供了一个集中的访问点，将对应用功能及其工作流的访问统一在一起。用户界面控制器调用应用控制器的时候，应用控制器负责找到应当执行哪项功能。
它可以将用户界面与逻辑交织在一起的部分封装起来，这样可以使页面控制器和页面逻辑分开。

## 命令处理程序（Command Processor）
### 作用
负责执行服务请求，将服务请求与服务的执行分开。它将请求作为独立的对象进行管理，调度请求的执行，为其提供日志、存储、撤销/重做等附加功能。

### 概念
客户端只能通过它向应用发出请求，处理程序可以访问组件的状态信息，它可以根据优先级、吞吐量等条件来调度挂起的服务请求，还可以执行一些辅助功能或者系统管理功能。

这样用户和用户组件就不需要关心如何组织具体服务请求的执行。降低了两者间的耦合程度。  
其它特性跟命令模式差不多。

## 模板视图（Template View）
### 作用
在模板视图中预定义好视图结构，并为动态的数据设置好占位符，这样在显示时就可以让多个数据用一个视图来显示。

为每个视图引入一个模板视图组件，它可以使用某种特定的用户界面技术将应用数据或者其他信息用一种预先设定的视图格式展现出来。
类似网页模板。

## 转换视图（Transform View）
### 作用
通过它遍历从应用返回的数据结构，找到需要显示的数据，并将其转换成合适的输出格式。
将为响应特定的用户请求而从应用接收到的数据转换成数据上的具体视图。
### 概念
它是一个适配器，将一种类型的输入转换成另一种类型的输出。控制器从应用收到请求的响应数据，就将其传递给转换视图，然后接收到具体视图并将结果显示出来。

在返回数据的时候，有些数据可能不应该显示或者需要处理，可以使用这个来转换。

## 防火墙代理（Firewall Proxy）
### 作用
保护应用公开功能的访问，防止客户端的服务请求中嵌入攻击代码。  
为应用中可以公开访问的功能引入一个防火墙代理，通过它为每个客户端请求添加相应的安全策略，从而保护实现该功能的组件免受攻击。  
这个代理可以检查服务请求，发现其中的可疑内容并将其移除。
### 概念
外部客户端只能通过它访问应用的功能，客户端向代理发出请求，代理根据相应的访问规则检查该请求，如果可接受，就把它传递给受保护的组件，否则请求就会被拒绝。  
就是在客户端和服务组件间加入一层用来检查数据的正确性。  


## 授权（Authorization）
### 作用
如果一个子系统本身是对安全敏感的，在客户端向其发送服务请求的时候，为客户端分配合适的访问权限，并在子系统执行每个请求之前检查这些权限。  
它检查客户端访问权限，确保只有符合指定访问规则的授权客户端才可以访问应用的特定功能。  

### 实现
这个模式在连接时创建权限对象，之后使用的函数都需要传入，并且在函数中检查权限。  
一般会定义好一些权限角色，这样可以根据角色权限的不同来控制访问。  
可以设置一个全局的权限引用，服务都会向它检查权限，这样可以避免代码重复，简化维护工作。  
可以部署多个，以免出现单点失败和性能瓶颈。  

# 对象间交互
## 观察者（Observer）
## 中介者（Mediator）
## 命令（Command）
## 备忘录（Memento）
以上略。


## 双分派（Double Dispatch）
### 作用
将调用者对象作为附加参数传递给接收者对象，在接收者中，回调调用者对象以运行与调用者类型相关的逻辑，将接收者作为一个附加参数传递给调用者，以便调用者得以执行正确的行为。

在访问者模式中使用，但是可以分离出来单独使用。

## 上下文对象（Context Object）
### 作用

以组件对象的形式捕获环境服务和信息，以支持将这些信息传递给其它需要获取执行上下文的服务和插件对象。  

可以在不改动配置或系统其它部分代码的同时，对组件的执行上下文进行修改。还可以在不同的上下文中运行同一个程序。  


## 数据传输对象（Data Transfer Object）
### 作用
将所有可能需要的数据项合并到单个传输对象上，使用该对象来对属性进行集中的查询和更改。

这使用在需要修改或获取远程对象的值时，如果为每一个属性执行一次函数调用是非常低效的，使用这个只需要一次调用就可以完成对属性集合的查询和更新。  

## 消息（Message）
### 作用
将需要通过网络传输的方法请求与数据结构封装到消息中，消息包含信息头（定义消息类型、来源、目标、大小等）和内容。
就是一般的发送方式，没什么可说的。

# 模态行为
## 状态对象（Object for States）
同状态模式，略。
添加Object修饰是强调实现的方式。

## 状态方法（Methods for States）
### 作用
将状态相关的行为实现为对象的内部方法，并使用数据结构以指向代表特定状态行为的方法。  
就是用函数/成员函数来代替状态对象，通过函数引用调用。  

## 状态集合（Collections for States）
### 作用
将感兴趣的不同状态表示为单独的指向状态对象的集合。  
这里的意思是，某些对象不适合（或不应该，或者需要批量管理）标记现有的状态，这时候可以将相关状态的对象放到状态对应的集合中。

### 实现
可以统一对该状态集合的元素进行跟状态相关的操作，当状态改变时就从集合转移对象。  

### 缺点
不过当状态数量增长时，这个模式就不太适用了，因为会引入资源管理和性能开销；如果状态变化很剧烈，也会带来在集合间传递对象的开销。
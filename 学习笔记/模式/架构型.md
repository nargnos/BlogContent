---
title: "[模式] 架构型"
date: 2017-09-03 16:55:42
tags: 模式
categories: [学习笔记,模式]
description: 不全待补
---
体系结构模式表示软件系统的基本结构化组织。它提供一套预定义的子系统，规定它们的职责，并包含用于组织它们之间关系的规划和指南。

_这类模式不应该跟设计模式放到一起（因为框架是大局观，设计模式是操作方法，惯用法是操作细节），因为我不想分得太细（会造成某个分类文档过少），而且wiki上的模式分类和一些书上的分类有冲突，也不好判定谁对谁错，所以就混在一起放。_
_看的这本书翻译也有问题，大部分语句都需要猜它原本想要表达的是什么。_  
<!--9 10-->
<br/>

# 从混乱到有序
将混乱的结构组织成可移植、可维护、可理解和稳定的结构。

## 域模型（Domain Model）
### 作用
创建一个模型来定义系统的业务职责及其变化范畴，模型元素是对应用领域的有用抽象，其角色和交互反映了该领域的工作流。

就是定义一个具体模型（工作流图）来指导开发。  


---
## 层（Layers）
多层（Multitier/n-tier/multilayered）
用于分解大系统
### 作用
分层帮助将应用结构分解为子任务群，使各层可以独立的开发，每一层都有明确而具体的职责。

_比如网络协议的分层，或者在介绍框架时一般会附带一张结构图，基本都是层次结构。_  
### 概念
将系统分层，按次序排列，底层是系统基础，其上的**每一层都只用到下一层提供的抽象**（没有更进一步的直接依赖关系），直到顶层。在某一层中用到的所有组件都工作在同一个抽象层。每个独立层都要防止较高层直接访问较低层。    

在使用时向顶层发送请求，如果不能完成这个请求该层就向下传递，直到底层；在请求处理完成后，便一层层向上传递回顶层。在传递时可以判断这个事件是否应该继续往下传递，如果不需要，可向上层返回处理结果。可以在某一层缓存请求结果，这样在请求传递时可以检查缓存直接返回结果，而不需要传递到底层。    
也可以像网络协议那样使用，每一层附加一些解析信息，一层层添加完毕后传递给其它对象，再一层层解析出来。

划分的标准可以通过各种不同的维度来定义，比如抽象性、粒度、硬件距离以及变化率。
划分的关键问题是确定合适的层数；太少可能无法将系统的不同问题充分的分开以便独立升级；太多会导致架构过于零碎而没有清晰的视图和范畴，从而难以改进，另外还可能还会引入性能问题。
为每一层提供一个接口并公开给其它层访问，控制和数据流可以**双向传输**，往上可以用回调或命令的方式传送数据，往下通过调用下层接口。  


### 实现
可以用以下步骤构建，但不是所有步骤都是必须的：
1. 定义分层的抽象准则
2. 根据抽象准则定义抽象层数
3. 给每个层命名并指定其职责    
4. 指定服务
    把较多服务放到高层更好，注意层之间要严格分离，但如果需要共享模块（数据定义等）可以不那么严格。
5. 细化分层
    重复之前的步骤，直到得到一种自然稳定的分层。
6. 为每个层指定一个接口
    尽可能的把这些接口封装在一个外观对象之中。
7. 构建独立层
    如果独立层很复杂，可以用桥接或者策略模式来构建。
8. 指定相邻层间的通信
    常用的是推模式。当请求下层服务时使用。也可以用拉模式，可以使低层自行从高层获取可用信息。
9. 分离邻接层
    请求自顶向下传输时，可用返回值传输结果。当自底向上通信时，可以用回调来获得相关数据。如果消息需要向上又要向下传输，明确把低层连接到高层更好。
10. 设计一种错误处理策略
    对于分层结构，错误处理在处理时间和编程工作方面的代价较大。尽可能的在低层处理错误，防止高层被许多不同错误和大量错误代码搞复杂。把相似的错误类型归类，注意错误类型是否需要设置成所有层共享，否则高层可能无法理解低层抽象的错误信息。

### 扩展
当性能比可维护性重要且接口稳定时，可以使用松散的分层结构，就是允许高层直接访问所有低层的服务，而不是只访问邻接层。  

### 特点
层重用、标准化支持、局部依赖性、可替换性

### 缺点
层的行为改变时可能要在一些层上做一些重复工作以合并局部改动。  
分层会存在粒度大小的问题，需要合理分层。
性能不高，因为需要在层之间传递数据。

### 三层架构
最广泛使用的多层结构。  

**一般**分为
* 表现层（UI）：最顶层，直接与用户交互的界面，用于接受输入和显示数据。
* 业务逻辑层（BLL）：中间层，用于连接DAL和UI，实现业务逻辑，实现程序功能；务逻辑具体包含：验证、计算、业务规则等。
* 数据访问层（DAL）：底层，操作数据库并提供相应API。

各层之间用实体类（Model）进行通信，每一层都需要引用它。实体类就是对数据的映射，是存储数据的对象。
数据流向为 UI->BLL->DAL(处理并返回数据)->BLL->UI

---
## 管道和过滤器（Pipes and Filters）
用于处理数据流
### 作用
为**处理数据流**的系统提供了一种结构：每个处理步骤封装在一个**过滤器组件**中，数据通过相邻过滤器之间的**管道传输**，重组过滤器可以建立相关系统族。  
也就是将应用的任务划分为几个自我完备的数据处理步骤并将这些步骤通过中间数据缓存连接到数据处理管道中。  

### 概念
在创建处理或转换输入数据流的系统时，需要把任务分解成几个阶段，而且需求容易变动，可以用这个模式解决。  
把系统任务分成几个顺序的步骤，每个步骤由一个过滤器组件实现，步骤间采用数据流连接（前一个步骤输出是下一个步骤输入）。  

**过滤器**在产生任何输出之前会将它的输入全部处理，系统的输入由数据源提供，输出会被存储到数据汇点（比如文件什么的），这些过滤器、数据源、数据汇点由管道顺序连接，每个管道处理步骤间的数据流动。通过管道连接的过滤器序列叫处理流水线（Processing pipeline）。

过滤器是流水线的处理单元，它可以丰富、提炼、转换它的输入数据。
流水线可以等待数据流入或者主动从连一个流水线拉出数据（推拉模型）。  
可以用循环的方式工作，从流水线取得输入数据并将输出数据输出流水线。   
可以将流水线设计为一个独立的程序或线程。  

**管道**用来处理它们之间的连接，不过如果过滤器用推模型实现的话，在管道中需要调用相关的函数，会使过滤器重组更加困难。  
管道可以设置一个缓冲区，如果过滤器是独立的线程，还可以将管道设计为一个队列用来同步。  

**数据源**是系统的输入，可以主动将数据推入第一个处理阶段，也可以在第一个过滤器拉取数据时提供数据。

**数据汇点**收集流水线的结果，可以主动的把结果拉取出来，也可以被动的等前面的过滤器推送结果。

### 实现
可以使用系统服务（如消息队列或管道）来连接管道（指的是模式中的管道）或者可以直接调用，使用不同的方式连接会有不同的实现步骤。
一般步骤如下：
1. 把系统任务分成一系列处理步骤
    每个步骤只依赖前一步骤的输出，通过数据流将所有步骤相连。
2. 定义管道传输的数据格式
    统一的格式使重组过滤器变得更灵活。如果需要不同的数据格式，可以创建一个转换过滤器来对数据进行转换。另外还需要定义结束标识，可以用一个特殊值来表示结束。
3. 决定如何实现管道连接
    决定是用主动还是被动的形式（推拉模型）使用过滤器，如果统一形式，可使过滤器能随意重组。可以用系统的一些机制实现。
4. 设计和实现过滤器
    过滤器可用推拉模型实现，可以放到单独的线程中运行。如果需要拷贝数据，可以在管道内设置缓冲区。可以定义全局环境、数据仓库或配置文件供过滤器使用。
5. 设计错误处理策略
    流水线组件不能共享任何全局状态，所以当发生错误时不好处理。可以定义一个特殊管道输出错误（类似stderr）。或者在过滤器发现错误时忽略输入直到下一个分隔点，或者引入特殊标记值来给数据流做标记。捕获到错误时可以重启流水线或者等待有正确的输入再继续处理。
6. 建立处理流水线
    可以将中间结果存储在文件中，并将文件作为流水线输入，这样可以支持流水线增量式开发。

### 扩展
过滤器可以不止一个输入或一个输出。
可用并行来提高处理效率。  

### 特点
增加灵活性
### 缺点
过滤器之间传输数据在转换时有额外开销，错误处理是这个模式的弱点，如果流水线在处理时不可重启或不可忽略错误时应该换另一种模式。

---
## 共享仓库（Shared Repository）
某些应用是数据驱动的，组件之间的交互不遵循特定业务流程，而是依赖于操作的数据。这会比较难将程序的各个部分连接起来，但是还是要保证它们之间的交互可控。  
### 作用
将所有数据维护在中心仓库（Central Repository）中，并被数据驱动应用的**所有功能组件共享**，同时让数据的可用性、质量及状态来触发和协调应用程序的控制流。  
帮助结构化那些功能和协作均由数据驱动的应用。它负责维护应用组件的公共数据，这些组件在共享仓库中能够自行访问并修改数据，此外，其中的数据状态影响特定组件的控制流。  
### 概念
组件直接工作在共享存储库维护的数据之上，这样其它组件可以在数据变化时做出反应（观察者）。如果创建了新的数据，或者从环境中接收到新的数据，也一起放进去，以便其它组件访问。  
存储库的访问需要同步，因为可能会被多个应用组件访问；应用组件不需要关心其内部实现。存储库可以通过相应的质量属性来表示数据的质量（如最新、过时、不确定、损坏等），组件可以用该信息来控制对该数据的特定处理。  


---
## 黑板（Blackboard）
可作为行为树的辅助模块使用。

### 作用
对于**无确定性求解策略**的问题比较有用。在这个模式中有几个专用子系统收集信息并建立一个可能的局部解或近似解。  
通过将多个具有确定性解决方案的算法或更小的组件结合起来，使用启发式的运算来解决这类任务以逐渐改善过渡性的假定解决方案。

### 概念

当需要做一个决策的时候，需要输入一些外部信息，如果为每个外部信息都设置一个接口，会导致接口复杂，把这堆数据集中在一个数据结构中处理，可以使调用简单化而且可使使用者更像一个黑盒。
其思想是多个独立程序集共享一个数据，可以放入不同的数据供感兴趣的程序使用。

针对的是那些在把原始数据转换为高层数据结构方面没有可行的确定解的问题，这些问题常常出现在一些不成熟的领域，其中没有相近的已知方法或可行的方法。  
将一个问题分解成若干子问题时，部分问题需要跨几个领域的专业知识，并且需要不同的表示和泛型。许多情况不一定能产出最优解，有可能得到次优或没有解；有可能在给定时间无法搜索所有的解空间（所有可能解的集合），或者领域还不成熟。所以黑板系统需要仔细做文档，并且如果重要的决定需要依赖它的结果，必须验证这个结果。  

这个模式的思想是让多模块在一个**公共数据结构**上**合作**。每个程序用来解决整个任务中的一个**特定部分**，**所有**程序一起工作以解决问题。这些程序彼此独立但不相互调用，它们的活动也没有预先确定的顺序，系统的执行方向主要由当前状态决定。并设置有一个中心控制组件评估处理当前状态，协调各个程序。

在求解过程中，系统通过将求解方案组合、更改、否定来工作。每一个解表示一部分问题和其解法的一个阶段，解空间被组织成几个抽象层次，最低层次由输入的一个内部表示构成，系统的潜在解决方案处于最高层。  

另一本书的描述：将系统中的全部任务划分成小的子任务，这些子任务都有已知确定解法，再为每一个子任务的职责分配一个独立的知识源。为了允许知识源可以按照任意顺序彼此独立运行，可以让它们通过非确定性的数据驱动机制来合作。通过使用共享数据仓库和黑板，知识源可以判断它们是否有输入数据可用、处理输入数据以及交付结果，这些结果有可能形成系统中其它知识源的输入。  
使用一个控制组件来协调计算，采用尝试性启发式方法选择并激活适当的知识源，如果黑板上的数据不能作为最终数据，则重复执行，否则停止计算。这种策略是**通过对部分结果的增量式改进和对不同假设的估算来获得问题的解，而非通过确定的算法**。  


### 实现
把系统分成**黑板**组件和**控制**组件，黑板组件由**知识源集合**构成。
黑板是中心数据仓库，它提供了一些读写接口，存储的是解空间的元素和控制数据，黑板中出现的数据元素称为**词汇**。

解空间的所有元素都能出现在黑板上。  
对于在求解过程中构建并放在黑板上的解，称为**假设**，后期被否定的假设要从黑板中删除。  
**知识源**是求解特定方面问题的独立子系统，它们一起模拟了整个问题域，它们中没有哪个能单独解决系统的任务。  
知识源之间不直接交流，它只从黑板读写，所以它们需要理解黑板的词汇。知识源在两个抽象等级上起作用，如果它向前推理，就将解法转化成高层解法；如果反向推理，就要在低层搜索；如果推理过程不能得出结论，可以反向参考低等级解法。
知识源分成两个部分：
* 条件部分：评估求解过程的当前状态，确定在黑板上的内容是否有用。通过审核黑板中的数据来检查该知识源是否能对运算过程做出贡献。  
* 行动部分：生成能导致黑板内容改变的结果。

**控制**组件用循环监视黑板的改动并决定接下来采取什么动作。它根据知识应用策略根据黑板上的数据安排知识源评估和行动。  
策略可以依赖控制知识源，这些知识源可产出控制决定，它们产出结果被保存在黑板上称为控制数据。  

在控制组件实现时，首先读取系统输入并保存到黑板，然后循环这些步骤：
1. 调用所有知识源的条件部分来判断在当前运算状态下是否有用
2. 使用启发式算法来分析条件部分返回结果以确定哪一个知识源对运算进程最有效
3. 激活选中知识源的行动部分，修改黑板内容

黑板如果包含了一个正确的最终结果则循环结束，或者当没有知识源能改进任意中间假设方案的质量时也结束循环。

这个[例子](https://social.technet.microsoft.com/wiki/contents/articles/13461.blackboard-design-pattern-a-practical-example-radar-defense-system.aspx)可能会有助于理解。  

一些地方说可以用key-value的形式实现。

在实现时需要执行以下步骤：
1. 定义问题
2. 定义问题解空间
3. 将求解过程分成几个步骤
    定义解如何转换成高等级解决方案，描述在同一抽象等级上如何得出假设，细化如何从其它等级中找出能验证假设的数据，详细指明可用于排除部分解空间的知识类型。
4. 把知识分成和子任务相关的特定领域知识
5. 定义黑板的词汇
    详细拟定解空间的最初定义和解的抽象等级。找到解的一种表示，使所有知识源可从黑板上读取并产出，每个知识源必须能确定它是否能用这个假设（它可以不理解这个假设，但必须确定是否能用）。如果有必要可以提供假设和知识源内部表示之间的转换。  
    为了评估黑板的内容，控制组件必须能理解词汇，所以词汇不能只定义一次，它需要随知识源和控制组件的定义一起进化。在设计过程的某些节点上，词汇必须稳定，并且允许知识源稳定接口的开发。  
6. 确定系统的控制策略
    需要判断一个假设的可信度（可以在0~100之间），删除低可信度的假设。
    把对黑板的改动分为两种类型。一种是新的可用知识源，另一种是其它改动，这时候控制组件选择一个未对所有条件调用的知识源（这里翻译有问题，猜不出在说什么）。
    黑板的关联种类随可用的知识源一同改动。使用队列来保存知识源的有价值信息，并用优先级来排列可应用知识源。如果控制组件有复杂和独立的子任务，则为每个子任务定义控制知识源。
7. 实现知识源
    将知识源分成条件、动作两部分。可在同一系统中用不同技术来实现知识源。



### 特点
可使用不同算法来搜索解空间，知识源可重用

### 缺点
测试困难，不能保证有解，低效，开发麻烦，缺少对并行机制的支持

---
## 域对象（Domain Object）
### 作用
将应用中所有明确的功能封装为一个自我完备的构造块。
为域对象提供一个跟实现相分离的接口，每个域对象程序只使用这些接口来访问其它域对象。  
将自我完备的连贯功能和基础性责任封装成定义良好的实体，通过一个或多个显式接口提供功能，并隐藏内部结构和实现。  

### 概念
将应用中不同功能的职责分开，每个功能都各自封装，从而可以独立改变。  


---
# 分布式系统
## 消息传递（Messaging）
有些分布式系统是由独立开发的服务组成的，但是如果要组成完整的系统，这些服务必须能够可靠的交互，同时又不能产生过分紧密的依赖关系。
### 作用
通过消息总线连接不同服务，允许它们异步地传递数据消息。对消息进行编码，这样发送者和接受者不必静态地了解所有的数据类型信息即可可靠的通信。  

### 概念
客户端动态地把固定类型的消息发送给特定的远程服务，而不发给特定的方法。所以它可以实现多对一的通信方式，同时不需要静态地预定义接口，否则这个接口会导致客户端对服务的依赖。

构成分布式系统的服务通过**消息总线**连接（多个服务共同连接一个总线，由总线分发消息）在一起，利用消息总线异步地与其他服务交换数据信息。  
消息通常是自描述的，它既包含描述结构的元数据还包含相应的数值。消息对它的发送者与接收者及消息中间件都隐藏了内容的具体数据格式，这样对数据格式的修改对于系统就是透明的。可以用xml、json等作为消息格式。    

消息客户端只知道所用的服务端点，不知道服务的特定接口，所以在将消息发送到特定的服务前，无法静态的检查消息的格式和内容；由接收消息的服务解析消息，这包括验证和提取消息内容，如果无法理解消息中的一些域，可直接忽略，因为有些消息格式设计的时候并没有考虑它们的协作。  


### 特点
松耦合

### 缺点
缺少静态定义的接口，处理自描述信息会有开销

## 信道（Message Channel）
增加消息交换的可靠性
### 作用
将彼此协作的客户端和服务连接起来，使它们能够交换消息。  
### 概念
当客户端准备通信时，将消息写到Channel中，处理它的服务可以提取并处理消息。  
消息的接受者一定对其包含的信息感兴趣，可以进行使用和处理。  
连接的方式可以是点对点、或者出版者订阅者的方式。  


## 消息端点（Message Endpoint）
### 作用
当数据传送时需要将数据转化为可传输的格式，读取时又要转换回来，这会造成应用与消息中间件所需的格式之间形成紧密耦合。
可以在传输过程中设置一个单独的过程来转换和解析消息。

### 概念
Message Endpoint**为客户端和服务封装了消息中间件的细节**，并且对中间件的通用api做了专门的客户化。这样在消息机制改变时可以对应用完全透明。

## 消息转换器（Message Translator）
### 作用
当消息的发送者和接受者使用不同的消息格式时，可以将消息从一种格式转换为另一种格式。  

### 概念
提供**双向消息格式转换**，客户端可以用其它格式来发送消息，Translator能够保证服务接收到的格式是它能够理解的。

## 消息路由（Message Router）
互相协作的客户端和服务之间交换的信息，必须通过消息基础设施进行路由，但是这三者**都**不应该知道如何选择路由途径（消息在系统中传递的路径）。
### 作用
将来自某些Channel的消息根据一系列条件重新插入到不同的Channel中。  
它可以将一系列Channel连接成一个网络，从一个通道中读出消息，将它路由到另一个通道里，这个通道最终会将消息传递给预期接收者。  
### 概念
把消息发送规则集中到一个位置，如果定义了新的消息类型，可以很容易做出局部修改；必要时还可以插入新的消息路由；这对应用来说是透明的。  

在部署的时候必须仔细计划和配置消息路由的数量和类型；包含越多，消息在不同组件之间路由的方式就越灵活，但是交换效率就越差。

可以根据系统负载或者故障情况选择目标，也可以根据消息某些特定属性来选择。  
还可以将大型消息转换为多个小型消息分别路由，或将多个消息合并路由；可以将失序消息排序后重新发布。

在实现控制逻辑时可以是静态配置也可以是动态配置，静态开销低但不灵活，动态相反。  


### 缺点
会给应用增加额外处理过程，可能会降低性能。
它必须知道与它相连的Channel，如果变化频繁会带来很高的维护成本。

---
## 发布者-订阅者（Publisher-Subscriber）
### 作用
改变组件内部状态可能会引入合作组件之间的不一致性，为重建一致性，需要一种机制来交换这种组件间的数据或状态信息。
定义一个用于传播变更的机制，允许在分布式应用中通过Publisher发送事件，事件可以承载对其它组件有用的信息；在信息发布后，会通知对这些信息感兴趣的组件。  

用于不同的服务和组件通过一对多的关系异步交换事件来相互作用的系统。
### 实现
组件间应该松散耦合，信息提供者不应该依赖协作者的细节，并且信息提供者的组件并不是预知的。  
**订阅者和发布者不直接耦合**，发布者和订阅者能够相互独立地运行。  
发布者将消息发送到一个中介者（用来调度，跟观察者不同的是需要一个调度器，这个调度器不一定跟发布者接收者同一个进程），订阅者向这个中介订阅（可设置订阅规则如过滤某些消息），消息的传递由中介者调度，这样发布者和订阅者之间就不存在依赖关系。  
观察者的推拉模型也是可以应用到这里来的。

消息的发送是可以一对多的，如果有多个订阅者对同一事件感兴趣，模式会将事件转发到所有关注它的订阅者。  

### 缺点
当订阅者只对某一种符合规则的事件感兴趣时，需要基于事件进行过滤和分发，这样会带来一些开销；如果在组件内部过滤会影响系统吞吐量，如果在订阅者过滤就会有一些不必要的通知；如果在发布者过滤就会破坏这个通信模型。


---
## 经纪人（Broker）
用于带有独立协作组件的分布式（可能是异构）系统。
### 作用
在分布式系统中，可以通过使用一系列Broker，从应用的功能中**隔离并封装通信基础设施的细节**。这样客户端可以像使用本地服务一样，调用远程服务的方法。  
可以用于构建带有隔离组件的分布式软件系统，通过远程服务调用进行交互，**Broker负责协调通信**（比如转发请求、传递结果和异常）。

### 概念

用于不同组件通过远程方法调用来相互作用的系统。通过它，很多客户端可以调用托管在服务器上的远程组件对象的远程方法。因此客户端可以按照多对一的方式与服务器通信。  
并且它们描述功能的接口通常都是静态类型的。如果希望隐藏网络的存在，使用这个模式最适合。  

构建一个复杂的软件系统，它是独立和可互操作的组件集合而不是一个整体程序，从而有较大灵活性、可维护性和可变更性。通过将功能分割成独立组件，让系统变得可分布和可扩展。  

当分布式组件相互通信时需要一些进程间通信机制，如果组件自身处理通信，最终系统会依赖所使用的通信机制；这些服务器程序不应该依赖特定的系统细节以确保在异构网络中的可移植性和互操作性。  

引入代理者可较好地做到客户机和服务器的隔离。**服务器**向代理者**注册**自己，使其服务通过接口能被客户机所使用；**客户机通过代理者发送**请求访问服务器功能。代理者的任务包括**定位**合适的服务器，将请求**转发**到服务器并向客户机**回送**结果和异常。

这个模式降低了开发分布式程序的复杂性，应用程序能够简单地通过向合适的对象发出消息调用访问分布式服务，而不是把重点放在低级进程间通信，并允许对象动态改变、添加、删除和重定位。  

代理者提供了分布技术和对象技术，它也将对象模型从单一程序扩展到运行在异构机器上并可用不同语言来编写的分布式应用程序。

代理者使得分布式应用中的组件交互的时候不需要处理与远程相关的问题。它可以根据客户端和服务器组件的位置选择使用远程方法调用还是本地方法调用，如果在同一地址空间内，代理者可以优化通信路径以减少不必要的开销。  

对于每个参与系统的网络节点，至少要为它定义一个Broker实例。组件的接口和位置被注册到它们本地的Broker上，以此来获得在分布式系统内部的可见性。  
为了调用组件上的函数，客户端会像本地的Broker请求一个远程组件代理，并调用它的方法发起到远程组件的请求。代理通过与客户端和服务端的Broker协作，向组件发送、接收数据。  

就是将通信的细节隔离出来（隔离成Broker），并使用代理对象访问它，这个代理对象需要从Broker查找获得（这样可以通过对象修改是通过Broker间接通信还是直接与目标服务通信）。Broker可以在本地也可以在其它位置。


### 实现
参与组件：
* 服务器：实现通过接口展示功能的对象，这些接口通过接口定义语言（IDL）或二进制标准来获得，有两种类型的服务器：
    * 为许多应用领域提供公共服务的服务器
    * 为单一应用域或任务实现特定功能的服务器
* 客户机：访问至少一台服务器的服务的应用程序，它通过代理者转发请求，在操作执行后，他们将收到来自代理者的应答。客户机与服务器之间的互操作基于一种动态模型，它意味着服务器也可以做客户机，它们之间的关系并不是静态定义好的。客户机不必知道服务器的位置，这可以允许在系统运行期间增加或移动服务。  
* 代理者：负责在客户机和服务器之间传送消息的信使。它需要某种手段定位消息接收者（如唯一标识符）。它需要向客户机和服务器提供用来注册服务器和调用服务器方法的API。
    当请求发送到本地代理者（允许在当前机器，远程的运行在远程节点）维护的一个服务器时，代理者将直接把请求传送到服务器。如果服务器未激活则将其激活；应答会由代理者转发到发出请求的客户机。如果指定的服务器由另一个代理者代理，则本地代理者将寻找一条到远程代理者的路径并用该路径转发请求，这就需要代理者能互操作。  
* 客户机端代理：代表客户机和代理者之间的一个层，用来隐藏通信机制。
* 服务器端代理：与上面相似，不过它负责接受请求，解析消息并调用适当的服务。
* 网桥（Bridge）：可选，用来隐藏两个代理者互操作时的实现细节。它可将特定系统细节封装。

有两种类型的代理者系统：直接通信、间接通信。  
为了较好的性能，一些代理者仅建立客户机和服务器间的通信链，剩下的通信由参与的组件之间直接进行（直接传送而不需要中间层）。这种方法需要双方使用相同的协议。    
定义一个对象模型，服务器对象的状态及方法不应该被客户机直接访问，客户机仅能通过本地代理者传送请求间接改变或读取服务器的状态。  

实现时可遵循以下步骤：
1. 使用现有或定义一个对象模型
    需要描述服务器对象状态的定义、方法定义、怎样选择执行的方法和服务器对象如何产生和销毁，这些状态不应该直接被客户机访问，客户机仅能通过本地代理者传送请求以间接改变或读取服务器状态。
2. 确定系统应该提供哪种组件互操作性
    可以用二进制标准或引入IDL来设计互操作性（展示接口），二进制标准可以用指针来获得接口，或者用IDL可以在其它编程语言上实现；这两种方法也可以结合使用。
3. 指定代理者组件提供客户机与服务器合作的API
    客户机必须提供构建、发送请求和接收回应等功能。  
    服务器实现的API主要是向代理者注册。代理者使用仓库来维护信息，仓库可以是外部文件，这样服务器就可以在系统启动前注册自己。另一种方式是把仓库作为代理者的内部组成，这样代理者必须允许服务器在运行期间注册并提供相应的API。代理者需要在请求到达时确认这些服务器，因此代理者的服务器端API必须能产生系统唯一标识符。  
4. 用代理对象来对客户机和服务器隐藏实现细节
    客户机端代理对象将进程调用封装为消息并发送到本地代理者组件，并从本地代理者接受回应和异常并转发到客户机。
    服务端代理对象接受本地代理者请求并调用相应服务器的接口，并将回应打包返回到本地代理者。  
    代理对象通过自身进程间通信机制与代理者通信，以隐藏实现细节。  
5. 在设计API和代理对象同时设计代理者组件
    某些实现不通过代理者传递信息，这部分工作就由代理对象完成，但是代理者仍负责建立客户机与服务器之间的通信链。
    在设计和实现期间，需要重复如下步骤：
    * 指定与客户端代理和服务器端代理交互的协议
    * 本地代理者必须对每台机器可用
    * 系统必须记住由哪一个客户机发送请求，从而能把结果发送回去
    * 如果代理对象没有提供对参数和结果的编组和复组机制，就必须将该功能包含在代理者中
    * 如果需要异步通信，则可以在代理者或者代理中提供缓冲区
    * 代理者使用目录服务将本地服务器标识符和物理地址关联起来，如果使用tcp/ip，可以使用端口号作为其地址。
    * 当要求唯一标识符在服务器注册期间动态产生时，代理者需要提供产生标识符的机制
    * 如果要支持动态调用，代理者需要有维护服务器类型信息的机制
    * 注意失败的情况，一种是错误结果，一种是通信失败。有些代理者重复发送请求或回应多次直到成功，但需要保证请求仅执行一次，即使被再次发送。另外还要注意客户机试图访问不存在或没有权限访问的服务器的情况。注意要有完善的错误处理，否则测试和调试时会十分麻烦。  
6. 开发IDL编译器
    需要用编译器将接口定义转化为程序代码

对于**直接通信**的代理者系统，代理者告诉客户机服务器提供了哪一条通信通道，从而客户机可以建立与指定服务器之间的连接。
如果以传输数据为重点的话，需要在原始数据附加消息类型、结构和其它相关额外信息。  
### 特点
定位透明性，CS之间互相不必关心对方位置

### 缺点
容错性较差，如果代理者或者服务器失效，依赖于它的程序都不能成功地继续进行，可以通过复制组件来提高可靠性。


## 客户端代理（Client Proxy）
### 作用
在访问远程组件服务的时候，客户端需要使用特定的数据格式和网络协议。但是，如果将格式和协议信息硬编码到客户端中，将导致客户端依赖于协作组件的“远程性”，因为远程组件的调用和本地组件是不同的。
因此，在客户端地址空间提供一个客户端代理，它可以**代替远程组件**。它提供了与远程组件相同的接口，并将客户端的调用映射到特定的消息格式或协议，以便跨网络发送这些调用请求。 
### 概念
客户端的请求只能哦通过客户端代理发送到远程组件，代理会把具体的调用和参数转换为可被网络理解的数据格式，然后再用IPC机制将数据发送到远程组件；然后再将组件返回的结果转换为客户端能够理解的格式。  

它为客户端屏蔽掉远程组件接口上的变化。不过如果提供很多细粒度的方法时可能会需要多次代理调用，这会带来网络开销。  
它并不能完全实现通信位置无关性，因为它们必须先通过Broker获得，所以客户端组件的远程属性使已知的。
它可以确保客户端有权限访问远程组件，如果访问被拒绝，可以降低不必要的网络通信。  

## 请求者（Requestor）
### 作用
负责创建和处理请求消息，并将其发送给远程组件。这样可以使发送请求时不会依赖特定的网络协议和IPC机制。
### 概念
希望访问远程组件的客户端向请求者提供相关信息和参数，请求者将这些信息构造为一个消息，然后发送到远程组件。  

可以为所有客户端进/线程分配一个请求者，但可能会称为系统吞吐量和可伸缩性的瓶颈。
或者可以为每个客户分配独立的请求者，或者多客户端共享一个，但粒度较粗需要进行同步。

## 调用者（Invoker）
### 作用
将来自远程客户端的请求消息的接收和分发封装在组件实现的某个特定方法中。  

### 概念
它会在接收消息后对消息解析，判断应该调用那个组件的方法以及所需参数，然后把这个消息分派到指定的组件上。  
它可以为分布式系统中的应用逻辑屏蔽掉服务器端网络以及IPC任务和活动的诸多细节。  

它可以将多个子活动委托给其它组件，比如反序列化操作或者解析安全令牌等。

可以为应用中的全部组件只部署一个调用者，但是可能会造成性能瓶颈，应该让几个或者每个远程组件使用一个调用者。

## 客户端请求处理程序（Client Request Handler）
### 作用
代表客户端封装和执行所有的ipc任务。这样就不需要对每一个客户端都独立编写和执行这些任务。
客户端通过它发送网络请求和接收请求响应。  
### 概念
将一些底层的ipc任务比如连接管理、发送请求、分发结果、超时处理和错误侦测等独立成一个组件，该组件还需要负责网络和计算资源的高效管理和利用。在内部对所有客户端的网络资源实施集中化的执行和管理，可以提高分布式应用的服务质量，尤其是延迟时间、吞吐量、可伸缩性和资源的利用。
它还实现了接受者-连接者中连接者的功能。

## 服务端请求处理程序（Server Request Handler）
### 作用
代表远程组件封装和执行所有的ipc任务，比如从网络接收请求，并通过网络发送响应。

### 概念
类似上面那个，不过它实现的是接受者的角色。

---
# 交互式系统
保持内核功能独立于用户接口，因为内核功能通常保持稳定，用户接口常常需要变化。  

## 模型-视图-控制器（Model-View-Controller，MVC）
这个**模式**在web开发用得比较多，但是也可在其它情况使用。
这个也是分为三层，不过跟三层架构的一般分法不同，需要注意。
用于需要具有灵活的人机接口的交互式程序。   
这么分是因为这三个部分的变化率不同。  

### 作用
将一个交互式应用程序分为三个独立部分：处理（模型）、输入（控制器）和输出（视图）。采用变化传播机制来确保各部分的一致性。  

模型包含核心功能和数据，视图向用户显示信息，控制器处理用户输入。**视图和控制器**共同构成用户接口，**变更-传播机制**确保了用户接口和模型间的一致性。  

将各模块分层相互独立，降低耦合度，提高灵活性。  
分层有助于管理复杂的应用程序，并且可以简化分组开发，不同开发人员可同时开发这些模块
可以提高有大量界面且业务复杂的大型程序的健壮性。
### 概念
模式将交互式程序分为三个部分：处理、输出、输入。  

各模型职责如下(按层序排列)：
* 视图：显示数据，依据模型数据创建。一个模型可以有多个视图。   
* 控制器：处理用户交互，接受事件，向变更-传播机制注册自己并实现更新过程。本身并不输出任何东西也不做任何处理，只接收请求并决定由哪个模型去处理请求，然后再确定由哪个视图来显示数据。每个视图都有一个相关的控制器，用户通过控制器与系统交互。  
* 模型：用于处理程序的数据逻辑，通常负责在数据库中存取数据。模型与数据格式无关，可以为多个视图提供数据。注意这个需要处理的是逻辑和数据，包括了三层架构中的BLL、DAL、Model。  

注意控制器是不能操作视图的，视图并没有提供相应接口。视图和控制器可以相互依赖（可以有单向、双向）。

允许同一个模型有多个视图，如果用户通过一个视图的控制器改变了模型，所有依赖于该数据的其它视图应该反映出这种变化，当模型的数据改变时，需要通报所有视图。  

在初始化阶段，所有视图需要向变更-传播机制注册，每个视图创建一个合适的控制器（一对一的关系）。

在用户对View操作后，View捕获到这个操作，并交给Controller处理；Controller处理时可能需要对Model进行操作；当Model变更后，会通过观察者通知View（它们之间同步消息是通过观察者进行的），View收到这个消息会读取最新数据并更新界面。  
### 实现

可以按如下步骤创建：
1. 将人机交互从核心功能中分离出来
2. 实现变更-传播机制
    可以用出版者-订阅者/观察者来实现
3. 设计并实现视图
4. 设计并实现控制器
    对每个视图指定回应用户动作的行为。
5. 设计并实现视图-控制器关系
    可以用工厂方法来关联其关系
6. 实现MVC初始化代码
    首先初始化模型、然后创建并初始化视图，之后进入循环事件处理。
7. 创建动态视图
    如果允许动态打开关闭视图，可以创建一个视图管理者
8. 可替换控制器
    **可以对一个视图替换多个控制器**，比如可以替换只读控制器来使视图只读。
9. 层次化视图和控制器的结构
10.  进一步去除系统依赖性

书中的uml类图大致是这样：
View和Controller继承公共父类Observer（不需要独立的观察者）。Controller需要Model、View，View需要Model，Model可以注册Observer。  

在构建View的时候需要传入Model并向Model注册自身；构建Controller时需要传入View，从View取得Model并注册自身；或者可以在View中桥接Controller。
用户操作都由控制器处理，根据事件修改模型，在模型被修改后，它会通知视图更新显示。

**简单来说**就是将核心功能封装到Model中，将View和Controller关联，Controller接收用户输入并将它转换成对Model或View的请求。将这三个组件用变化传播机制（如观察者）连接起来，当Model发生变化时，其它两个都要做相应改变。  


如果显示和事件处理交织在一起，可以牺牲控制器的可交换性将视图和控制器合并，这种结构称为文档-视图。

Controller发出的请求可以封装到Command对象里并传给命令处理者执行，这样就可以允许它单独改变。  

### 特点
提高可重用性、松耦合、提高灵活性和配置性

## 模型-视图-提交者（Model-View-Presenter，MVP）
Web Forms/SharePoint, Windows Forms用
### 作用
将MVC的Controller改为Presenter。打破View对Model的依赖，其余跟MVC一样。  
### 概念
在进行操作时，View捕获用户操作后，转发给Presenter，然后P处理逻辑，Model通过观察者通知P而不是V，当P获取到变更信息后，通过V的接口更新界面。  
V需要提供操作界面的接口给P调用。  

## 模型-视图-视图模型（Model-View-ViewModel，MVVM）
Silverlight, WPF用
### 作用
对MVP的改良。使用VM将页面内容的数据抽象，其它类似MVP。
### 概念
ViewModel中使用属性绑定来进行数据同步，不再由Presenter手动同步，而是由框架的Binder负责，只需要告诉Binder绑定的是哪部分数据即可。


---
## 表示-抽象-控制（Presentation-Abstraction-Control，PAC）
当软件系统被分为多个且大部分时间互相独立偶尔有交互的子系统，并且每个子系统需要自己的用户界面风格时，这个模式才比较有用，一般用的少（相对MVC来说）。  
### 作用
某些应用需要通过不同的界面形式来操作其所提供的不同功能类型，将交互式应用结构化，使其形成由多个解耦代理（agent）构成的层次：一个顶层、几个中间层和多个低层代理。每个代理负责应用的一个特定功能并为其提供特定用户界面。  

以多层合作代理的方式定义了交互式软件系统的一种结构，每个代理负责应用程序的某一特定功能，并且由表示、抽象、控制组成，这种细分将人机交互部分 与 功能内核 和 代理的通信分隔开来。

### 概念
这个结构可对系统进行横向和纵向分解。它为某一特定的任务制定一个agent，所有的agent共同提供整个系统的功能。  
每个agent都维护它自身的状态和数据，所以agent之间需要有一个交换数据、消息和事件的机制。它们各自的人机交互方式常常差别较大，所以它们各自有各自的用户接口。使用这个结构，在替换agent时不会影响到整个系统。  

这个模式用**树状**层次结构构建交互式程序。它设置一个顶层，几个中间层和较多的底层agent，它们各自负责应用功能的某一特定方面，并且**每一个agent都由PAC三部分组成**。每个agent都依赖所有较上层的agent直到顶层。

agent的**表示**组件提供了**可视行为**；**抽象**组件构成**数据模型**，并可对这些数据进行操作；**控制**组件**连接** **表示与抽象**组件，并提供与其它agent**通信**的功能。
 
**顶层**
提供系统功能核心，控制结构层，其它绝大部分agent都依赖于它。
* 表示组件：通常没有什么职责，它可能包含共有的一些用户接口元素，在某些系统中可以没有顶层表示组件。
* 抽象组件：提供全局数据模型，提供操纵数据模型和检索信息的功能。  
* 控制组件：允许低层使用顶层的服务（存取和操纵全局数据模型），低层的服务请求被提交给抽象组件或表示组件。
    保存顶层和低层之间的连接信息，控制组件用这些信息确保顶层和低层之间的正确协作和数据交换。
    保存用户与系统的交互信息，可以跟踪调用，以提供对核心操作的历史记录或取消/重做功能。  

**底层**
提供具体视图，系统的用户仅和底层交互。实现了用户可与之交互的自我完备功能。  
* 表示组件：输出具体视图。
* 抽象组件：维护组件自身的数据。  
* 控制组件：维护表示和抽象，避免它们之间直接依赖。与较高层agent通信以交换事件和数据，输入**事件**被传送到底层的表示组件，输入**数据**被传送到底层的抽象组件，输出的**事件和数据**被发送到高层agent。  

**中层**
可完成两种不同的任务：合成与协作。
协调低层，并将它们组合成较高层次的抽象。
* 表示组件：实现用户接口。
* 抽象组件：维护中层组件自身的数据。
* 控制组件：类似底层和顶层的职责。协调从属的agent，将顶层数据模型发生的变化通知给底层，并组织它们刷新。


我**自己的理解**是（可能不对）：每一个agent都有表示-抽象-控制三个部分组成，多个agent组成树，也就是整个系统。在每一个agent中，用控制层解耦表示和抽象层。在构成整个系统的树中分为三层，顶层用来管理数据并提供管理接口，底层是显示数据和接收用户操作事件，中层解耦顶层和底层并定义不同的功能扩展方向。
用户通过表示部分与代理交互，对抽象部分相应功能的请求由控制部分协调，如果需要与其它代理协调，则会转发到其它代理的控制部分，并最终传递到其它代理的抽象部分。  

### 实现
需要如下的步骤，必要时可重复其中的某些步骤：
1. 定义应用模型
    分析系统应该提供哪些服务，需要哪些组件，各组件之间如何协作，操作哪些数据，用户如何交互等。  
2. 定义分层策略
    将共有服务提取到上层，全局服务放到顶层。注意层次越深越难维护，但是分多层可以更好的区分概念，这需要做权衡。
3. 明确顶层内容
    确定系统核心的部分内容，明确这些公共接口，这些都将是顶层的一部分。
4. 明确底层内容
    将模型组件分成最小的独立单元，确定每一个单元提供的人机交互组件，并使每一个语义概念都是一个独立的底层agent。  
5. 明确系统服务的底层agent
    对于每一个服务，都可作为一个独立的底层agent。 
6. 明确组合低层agent的中间层
    将几个低层组合成高层语义，并提供人机交互，使中间层可以基于它们组合的较低层agent进行操作。  
7. 明确与较低层协作的中间层
    协调较低层的操作，比如视图显示，当一个视图的数据发生变化时，其它视图中的数据也必须更新。  
8. 将核心功能从人机交互分离出来
    为每个agent引入表示组件和抽象组件，将表示数据分到表示部分，核心数据或操作分到抽象部分。可以使用外观模式给抽象和表示组件提供一个统一接口。然后引入控制组件来避免它们之间的直接依赖关系。
9. 提供外部接口
    这个功能是控制组件的一部分，控制组件是一个中介者（或者可以用出版者订阅者的方式），它可以将输入事件传递到期望的接受者，比如抽象组件或表示组件，也可以是低层或高层。对于所有agent，其通信和协作功能的接口都是相同的。
10. 将各层次连接起来
    将每个agent和与它直接协作的低层agent连接起来，并且允许动态的创建和删除低层agent，这些低层有动态扩展或减少层次的功能。当用户需要某个功能时就创建一个新的agent，不需要时就删除它。

### 扩展
可以配合一些并行模式（比如主动对象、半同步/半异步）使用，agent可以作为进程使用。

### 特点
事务分离、支持变化和扩展、支持多任务

### 缺点
系统复杂、控制复杂、agent之间的通信开销可能会影响系统效率

---
# 适应性系统
在设计期间可以应对软件系统的变化。
## 微核（Microkernel）
当应用存在多个版本时，所有版本都应该基于一个公共的架构和功能核心。这样可以避免应用在不同版本之间出现架构偏移，以降低共享功能开发和维护的成本。
### 作用
用于必须能够**适应变更系统需求**的软件系统。它把最小功能核心从扩展功能和特定客户部分分离出来，它也可以作为插入到这些扩展中并协调其协作的组件。
通过“即插即用”机制来扩展一个公共且最小的内核来为应用构造不同版本。  

### 概念
将平台上的基本服务封装到一个**微核**组件中，该组件包含进程间通信的功能，并且负责维护系统资源和提供存取接口给其它组件。
不能在微核中实现的核心功能应该分到**内部服务器**中，**外部服务器**实现了它们自己的微核结构，每个外部服务器是一个独立进程，该进程表示一个应用程序平台。一个微核系统可以被视为集成了其它应用程序平台的平台。客户机通过使用由微核提供的通信能力与外部通信。  

有5个参与组件：
* 微核：主要组件。实现了通信和资源处理机制，其它组件全部或部分建立在这个基本服务之上。许多系统特定的内容都被封装在内，维护像进程或文件那样的系统资源，并控制和协调对这些资源的访问。
* 内部服务器：扩展微核提供的功能，实现附加服务，封装某些系统特性。内部服务器只能由微核访问。目标是减小微核的存储需求和减少服务执行时间。
* 外部服务器：用微核实现，为客户提供编程接口。每个这样的外部服务器运行在一个独立进程上，通过由微核提供的通信手段接收来自客户机程序的服务请求，并解析和执行相应的服务，然后把结果发回客户机。
* 客户机：与外部服务器精确关联的程序，只使用外部服务器提供的编程接口。
* 适配器（也称仿真器）：避免客户机与外部服务器之间的直接依赖性。隐藏客户机的通信手段。如果外部服务器实现了一个现有的应用程序平台，那么相应的适配器会参照这个平台的编程接口实现。当客户机向外部服务器请求服务时，适配器会使用微核提供的通信服务把调用提交给合适的服务器。  


外部服务器实现特定版本的用户界面或api，要配置应用的特定版本，只需要将相应的内部服务器和微核连接起来，并提供合适的外部服务器来访问其功能。这样，应用的所有版本共享一个公共的功能和基础设施内核，但却能提供不同的功能和外观体验。  
客户完全通过外部服务器提供的接口或api访问微核的功能，外部服务器负责将所有接收到的请求转发给微核，如果微核实现了请求的功能就执行，否则**转发**给**相应的**内部服务器（_这是中介者的行为_）。返回结果也通过外部服务器传递给客户。  

改进某一特定版本以包含新的或不同的功能或特性，只需要重新配置合适的内部和外部服务器，微核自身不受这种升级的影响，已存在的内部和外部服务器以及应用的其它版本也不受影响。  

微核内部通常使用分层结构，底层从系统平台抽象出来，第二层实现基本功能，上层负责应用版本共享的功能，顶层包括内部服务器和微核机制。  
微核的转发功能用**中介者**实现，在需要的时候加载内部服务器，并控制其生命周期。

内部服务器也采用分层设计，但不提供转发层。如果内部服务器和微核在不同位置，可以不需要基于微核提供的服务实现功能，以降低网络流量。  

外部服务器可以是一个简单的适配器，也可以是复杂的用户界面。  


### 特点
可移植性、适应性和可扩展性

### 缺点
性能会有一定影响

---
## 反射（Reflection）
开放实现（Open Implementation）/元层次架构（Meta-Level Architecture）  
使架构能够依据不断变化和改进的技术、需求以及平台做出修改，但是通常很难预见哪些部分会发生变化或何时做修改。  
### 作用
为**动态改变**软件系统的**结构和行为**提供了一种机制。它支持诸如类型结构和函数调用机制等基本方面的修改。  

将应用的结构、行为以及状态方面的属性和变化因素具体化到一套**元对象**中。通过两层架构将元对象和核心应用逻辑分开，**元数据层**包含**元对象**，**基础层**包含**应用逻辑**。  

运行时行为可以通过维护所选系统属性的元数据来识别，从而使得软件系统具有自我识别能力。因此，改变保持在元数据中的信息可以改变接下来的基础行为。  
### 概念

在这种模式中，一个应用程序可以分成两部分：
* 元数据层：封装可更改的系统内部信息，提供所选系统属性的相关信息并使软件含自述信息；由元对象组成，它封装和表达了有关软件的信息；提供一个接口以方便对元数据层修改
* 基础层：包括应用程序逻辑，它的实现建立在元数据层之上，改变保存在元数据层上的信息会影响基本层次的行为（不需修改基本层次的代码）

操作元对象的接口被称为**元对象协议**，它为元数据层的变更提供一个接口，并负责检查变化的正确性，并完成这个变更。
它作为专门的接口供管理员、维护人员或者其它系统使用，在应用的监督控制下动态配置修改所有元对象。  
它常被设计为一个独立组件。它需要访问元对象的内部状态，可以为它提供一个只有它才能访问的元对象接口。



每个元对象封装了一个关于基本层的结构、行为或状态的信息，这个信息可以由系统运行期间的环境提供或从基本层获得，或者由用户定义。所有元对象构成程序的自述信息。元对象使原本需要间接获得的信息变得可直接存取和修改。
其它基础层的组件可以用这些元对象来确定它们的通信对象是远程还是本地的，它们可以选择最有效的函数调用机制与对方通信，这个调用机制可能由其它元对象提供。

基础层使用元对象来实现程序逻辑，元对象不允许基础层修改其内部状态，需要通过元对象协议才能修改。
基础层使用元对象提供的信息和服务，并且不需要关心它的通信对象的具体位置。

个人理解：将程序的某些方面比如行为、状态、属性等封装到元对象中，通过元对象协议配置其行为。然后在基础层使用（通过某些方式获得）这些元对象实现逻辑。这样在元对象表示的那个方面内容改变时，替换或修改元对象；当有新特性时，添加新的元对象。


### 特点
修改系统时不需要接触现有源代码，使更改系统变得简单
### 缺点
效率会低一些

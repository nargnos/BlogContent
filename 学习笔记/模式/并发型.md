---
title: "[模式] 并发型"
date: 2017-08-28 20:47:35
tags: 模式
categories: [学习笔记,模式]
description: 并发、同步、事件

---
_看的这本书的翻译不是很好，记的笔记不是很准确。_
<!--11 15 16-->
# 同步模式
## 区域锁（Scoped Locking）
c++惯用法，lock_guard相关，略。  

---
## 策略锁（Strategized Locking）
将锁作为策略传入，类似condition_variable中锁的用法。
可以在模板参数设置锁类型，这样锁可以随意替换，当不需要锁时传入null_mutex就可以取消掉锁的使用。
还可以用桥接的方式设置锁。

---
## 线程安全接口（Thread-Safe Interface）
使加锁开销减至最少，确保组件内部的方法调用不会因为要再次获得锁而自死锁。
### 作用
组件中调用方法时需要加锁，但是如果组件内部方法互相调用可能会造成自死锁。使用递归锁可以解决但是会引入不必要的开销。  

将组件方法分为可公开访问的接口和相应的私有实现。接口方法获取锁，调用相关实现方法，然后释放锁。实现方法假定已获取了必要的锁，它负责完成工作，而且实现方法只调用其它实现方法。
### 概念
简单来说就是公有函数加解锁，调用私有函数操作数据。在互相调用时就调用私有函数，这样就不会出现重复获取锁的情况。  

---
## 双检锁（Double-Checked Locking Optimization）
if-lock-if，可以先判断跳过加锁开销，多核情况需要注意用atomic保证内存一致性，略。  

---
## Future
_感觉翻译为未来（书里的）不妥，愿景好像也还行，但是应该还包含一层许诺的意思（因为后面需要用它得到值），不知道用什么词合适。直译就未来吧。_
### 作用
在调用服务时，立即返回一个虚拟的数据对象，该对象记录服务并发计算的状态，并在计算完成后向客户端提供具体值。  

之前写过，略。

---
## 阻拦（Balking）/挂起保护（Guarded Suspension）  
锁的使用方式，内容较少合在一起
### 作用
Balking: 防止某些操作被重复执行，当对应操作正在执行时，其它线程如果调用到相应函数就直接放弃执行。  
Guarded Suspension: 跟上面一样，但是在操作正在执行时就阻塞等待，如果开发时知道等待时间可能会过长，就应该选择Balking模式。  
_感觉比较简单，因为这个好像是比较常见的操作，一不小心就用到了_

### 实现
Balking
其实就是加个flag，当一个线程进入函数时标记使其它线程进入时直接返回。  
用锁（需要try lock）或者原子操作都可以实现，比较简单这里不扩展例子。

Guarded Suspension
其实就是很常见的锁操作。

## 复制变量（Copied Value）
### 作用
定义一个值类型，使其实例可复制，在用它来和另一个线程通信时，复制该值

通过复制对象来减少对象的同步开销。

## 不可变变量（Immutable Value）
### 作用
上面的模式在复制变量时会有构造对象的开销。这里定义一个值对象，其实例不可改变。其内部状态是在创建时设置的，并且不允许后续改变。
### 概念
没有任何改变就表示不需要同步。当需要改变属性时，只能通过替换引用来改变。在创建新对象时，可以基于旧对象进行创建。  


---
# 并发模式
## 主动对象（Active object）
并发对象。
使用异步方法调用（Asynchronous Method Invocation）实现

### 作用
将函数的调用和执行分离。  
将并发单元界定为组件上的服务请求，并且让它和请求的用户在不同线程上运行，使客户端和组件可以异步地交互来产生和使用服务结果。  
其实就是将对象的函数弄成异步，这样在执行时便不会消耗等待函数执行完的时间，加强了并发性。    

### 实现
需要实现一个命令队列（可以是优先队列），和一个线程（该对象自己管理，可以换成线程池）等待队列的命令（操作该对象的命令），在执行完命令后还需要有一个机制（比如回调）取得操作的结果。  
用C#很容易用async/await实现，C++下如果有ppl也比较容易实现。  

用C#感觉没什么可写的（实现起来代码太少），这里直接用asio（因为有现成的命令队列用，这样就不占篇幅）：
```c++
// include略
using namespace std;
using namespace boost::asio;
class Num :
	public enable_shared_from_this<Num>
{
public:
	explicit Num(io_service& ios) :
		ios_(ios),
		num_(0)
	{
	}
	// 这里直接将操作委托给线程（池）做，从外面看来这个操作是透明的
	future<int> Add(int val)
	{
		auto pms = make_shared<promise<int>>();
		auto ret = pms->get_future();
		ios_.post([pms_ = move(pms), self = shared_from_this(), val]()
		{
			// 假设原本这个操作需要很久
			this_thread::sleep_for(chrono::seconds(1));
			pms_->set_value(self->num_.fetch_add(val) + val);
		});
		return ret;
	}
private:
	io_service& ios_;
	atomic<int> num_;
};

int main()
{
	io_service ios;
	io_service::work w(ios);
	// 可以放到线程池里，这里用单线程
	thread t([&]() {
		cout << "Begin" << endl;
		ios.run();
		cout << "End" << endl;
	});

	auto num = make_shared<Num>(ios);
	
	auto ret = num->Add(123);
	// 这里不会阻塞，可以执行其它代码
	// ...
	// 这里阻塞等待刚才的操作
	cout << ret.get() << endl;

	ios.stop();
	t.join();
	return 0;
}
```
按照这个理解asio的socket就是一种主动对象（可能有误）。  


---
## 监视器对象（Monitor Object）
线程安全的被动对象

### 作用
同步化并发方法的执行，以确保同一时刻在对象内部只有一个方法运行，它也可以调度方法的执行顺序使对象方法相互协调。  

执行共享对象应该是在其客户端线程中进行，并让它能够自己协调这个串行化而又交错的执行序列。必须通过同步的方法对共享对象进行访问，确保同一时刻只能执行一个方法。  

### 实现
用户只能通过对象的同步方法来访问对象，这需要在对象内部包含锁，并将对象方法的访问同步化，以便一次仅有一个方法可以执行。
它提供一种机制，让线程在等待某个条件（阻塞）时不独占锁（需要用条件变量），这样其它线程就能访问这个对象（不会被阻塞）。  

其实就是一个同步对象，不过内部不需要有同步队列，而使用锁来使各个成员函数同步。因为没有自己的线程，所以处理时是被动的，所以叫做线程安全的被动对象。  

可以用条件变量、信号量等机制实现，简单，略。
注意当有可能发生嵌套调用时要换递归锁。


### 特点
简化并发控制和执行调度


---
## 半同步半异步（Half-Sync/Half-Async）
异步用于高效地处理底层系统服务，同步则用于简化应用服务处理。
### 作用
将并发系统中的**同步和异步过程分离**，**简化编程又不影响性能**。

### 实现
引入两个通信层，一个处理**同步**服务，一个处理**异步**服务。还有一个**队列层**协调异步和同步层之间的通信。
在独立的线程或进程中**同步**地处理**高层**服务，以简化并发编程；**异步**地处理**底层**服务，以增强性能。如果同步异步之间需要**通信**或同步处理，则允许它们通过**队列**层向对方传递消息，队列层可以让同步层和异步层以“生产者/消费者”的方式交互。  

在处理同步时需要开发者无需考虑异步的复杂性，同时也不需要考虑同步的低效性；同步和异步要能互相通信，而不会使编程复杂化或过度地降低它们的性能。  

外部事件源（比如socket）产生被异步服务层接收和处理的事件，异步层处理后，通过队列层将结果传递给同步层中指定的服务。
简单来说就是异步层接收事件，然后传递给同步层处理。  
同步层一般用多线程或多进程实现。  
队列层对消息进行缓冲，这样同步和异步服务可以并发运行。缓冲消息时可以在消息过多时可以丢弃消息或者阻塞队列。
异步层中的服务**不能阻塞**，如果产生过多的消息，就需要丢弃消息，此时会使发送者等待超时并重新发送被取消的消息。  

注意这里的同步和异步指的是层，一个层中可以有多个服务实体，比如可以有多个异步服务向队列发信息，或者可以有多个同步服务取信息执行。

#### 扩展
反应器构成异步层可以实现半同步/半反应模式。
反应器和前摄器可以跟这个模式配合（异步层）使用，虽然反应器不是真正的异步，但是如果它是短时操作不是长时阻塞，它就具有实现异步的属性。  


### 特点
事务分离

### 缺点
越过同步异步边界时会导致性能损失。  
可以让同步层和异步层之间共享内存区域，实现零拷贝。  


---
## 领导者/追随者（Leader/Followers）
### 作用
多个线程依次共享一组事件源，从而对源中产生的服务请求进行检测、分发和处理。

### 实现
为了将性能最大化，必须尽量减少与并发有关的开销（如上下文切换、同步和缓存一致性问题）。使用半同步/半反应时，在入队或出队消息队列时可能会导致大量的同步和上下文切换。  

简单来说就是多个线程轮流持有事件源，持有的就是领导者，其它线程就是追随者；追随者排队等待机会成为领导者。当领导者获得一个事件后，就将一个追随者提升为领导者，然后就去处理事件，处理完后就恢复到追随者的角色。这样多个线程可以并发地处理事件。  

这只需要在换事件源时进行同步。可以在接收事件时一次接多个，这样就可以降低交换次数。  
总体来说，这个模式比半同步/半反应模式有更高的性能，通过在线程间不交换数据来使加锁开销降低，并且在处理每个事件时不需要上下文切换。  



---
## 线程特定存储（Thread-Specific Storage）
线程本地存储
Thread-Local Storage

### 作用
tls，使每个线程中都持有一个相同声明的变量的副本。

### 实现
C++可直接用thread_local关键字，其它语言有各自的类库可用，比较简单，这里略

### 特点
使线程访问特定数据时不需要加锁

---
# 事件处理模式
这些模式有助于开发事件驱动应用程序。这些模式需要与并发模式相配合才能发挥最大作用。    

---
## 反应器（Reactor）
反转了应用中的控制流。  
EPOLL使用这个模式。采用同步IO。  
灵活高效的处理从多个事件源到达的事件。  
### 作用
多路分发并分配一个或多个用户的请求给相应的服务。
提供一个事件处理框架，使其可以同时等待多个事件源上所出现的服务请求事件，但是每次只分离和分发一个事件给相应的事件处理程序以完成其任务。  

### 概念
Reactor组件协调事件驱动应用的事件处理。它定义了一个事件循环，利用操作系统事件分离器在**一系列事件源上同步等待**服务请求事件的发生。通过将事件分离交给操作系统，Reactor能同时等待多个事件源而不需要在应用中采用多线程。当事件到达后，事件循环将事件逐个分发给相应的事件处理程序，然后每个事件处理程序执行相应事件的服务。  
事件处理程序直到处理完服务请求后才将控制权返回，所以单线程的Reactor适合短时间的任务操作。可以用半同步半异步或领导者追随者模式来优化。  

### 实现
执行时伪代码类似这个：
```
event_loop()
begin
	## 运行事件循环（无限）
	for(ever)
		## 阻塞等待事件发生
		event = demux_events();

		## 分发事件
		handler = identify_handler(event);
		handler.handle_event(event);
	rof
end
```

不应该被单个指示事件阻塞而排斥其它的事件源，否则会降低响应能力。  
为了使吞吐率最大，应避免CPU之间不必要的切换、同步和数据移动。  
新的或改进的服务应该能很容易集成已有的多路分发和分配机制。  
应用程序代码应尽量不受多线程和同步机制的复杂性影响。  

为每一个服务（事件）引入一个单独的事件处理器，并在反应器中**注册**；反应器使用一个**同步**事件分发（分离）器**等待**一个或多个事件源的事件，当事件发生后，分发器**通知**反应器，反应器将事件**分配**到相应的事件处理器中处理；处理完成后处理器**返还**控制权。     

分发器是一个函数，调用该函数何以等待在一组句柄上的一个或多个指示事件，该函数阻塞直到有事件就绪（意味着可以对句柄进行相应的操作而不会阻塞）。

反应器定义了一个接口，允许用户注册或删除相应句柄的事件。内部需要维护一个多路分发表，需要处理句柄、事件处理程序、事件类型间的关系。

等待指示事件，多路分发事件给具体的事件处理程序，这些是反应器的责任而不是用户的责任，事件处理者并不调用反应器，而是由反应器分配一个具体事件给处理者处理。


在注册事件时，可以设置两类事件处理程序。  
* 对象：用对象作为分配目标，可以很方便派生子类事件处理程序，可以很容易在一个组件中集成服务的状态和方法。  
* 函数：不需要定义继承新的子类就可以很方便的注册回调函数。

可以用适配器的方式同时支持函数指针和对象，在对象里存储函数指针即可。

在使用事件处理对象时，有这些策略可以选择：
* 单方法分配接口策略：只包括一个事件处理方法，反应器用此方法分配事件，将事件的类型作为参数传递给方法。
    该策略要求在具体处理方法中用大量的switch/if来处理特定事件，会降低可扩展性。
* 多方法分配接口策略：为每一个事件创建一个单独的处理方法。这样可以很容易重载基类中的方法，但是需要模式的实现者预先知道事件类型。


在注册事件时，用于注册的方式可以有这些特征：

* 两个参数：一个参数指明处理程序，另一个表示事件类型。
* 三个参数：第三个参数传入句柄显式传入句柄，尽管更容易出错，但是它可以为多个句柄注册同一个处理程序，有助于节省内存占用。  


通常使用单例反应器，因为一个执行过程（进/线程）有一个反应器就够了，不过需要注意，有些系统在单个线程里能够使用的资源有限。
多线程中的多个事件处理流程是并行工作的，所以需要配合一些额外的同步机制。

简单来说就是向反应器注册相关事件，当事件可用时就可调用关联的操作，当事件到来时表示可执行某个操作。  



#### 扩展
可以用主动对象、领导者/追随者、半同步半异步模式并发处理具体事件。
一个反应器的定时器机制应该允许程序注册基于时间的具体事件处理程序，可以使用不同策略实现定时器机制，如堆、偏差表、定时轮。

### 特点
事务分离、模块化、粗粒度的并发控制

### 缺点
不能同时支持大量耗时长的客户机请求，因为它在事件多路分发层串行化了所有事件处理程序的处理过程。  

---
## 主动器/前摄器（Proactor）
采用异步IO。  
IOCP使用这个模式。  
asio基于这个模式实现。  
更多相关内容见boost::asio的官方文档，那里记录了实现时需要的各个参与者。

### 作用
有效地多路分发和分配由完成的异步操作所触发的服务请求，在没有不利条件时，它可以获得并发的性能优势。  
将应用功能分解为在事件源上进行活动的异步操作和使用异步操作结果实现应用服务逻辑的完成处理程序。有操作系统执行异步操作，但在应用的控制线程中执行完成处理程序。  

### 概念
系统的事件分离器同步等待表明异步操作完成的事件的发生，开始所有完成处理程序“前摄性”地调用异步操作以等待服务请求事件到达，然后在Proactor中运行事件循环。当事件到达后，Proactor把完成的异步操作的结果分发给相应的完成处理程序，该程序再继续执行，比如调用另一个异步操作。  

这个模式允许在单一线程中同时执行多个长时间服务（只要完成处理程序不在同一时刻操作同一资源），从而避免多线程开销。增强了事件驱动软件的性能和吞吐量，将软件事件循环封装在Proactor中还使完成程序不需要关心异步事件分离和分发的复杂性。  

不同的平台会要求不同的实现，所以要将实现和接口分离开。完成处理程序通常使用接受者-连接者为服务处理程序异步建立连接。

### 实现
伪代码：
```
handle_event(Event event)
begin
	## 处理收到的事件
	if (event.type == REQUEST)
		## 异步读入请求
		## 将控制返回
		async_read();
	elif (event.type == READ_COMPLETE)
		## 处理事件，异步交付处理结果
		## 将控制返回
		process_data();
		async_write();
	fi
end
```
为应用程序所提供的每个服务引入一个**异步操作**，由这些异步操作通过一个句柄和完成处理程序（回调）来主动地初始化对服务请求的处理（提交异步请求），完成处理程序处理包含这些异步操作结果的完成事件。


通常由系统内核实现异步操作处理器（异步IO由操作系统完成），当**异步操作执行完**后，异步操作处理器便产生相应的**完成事件**，并将完成事件**插入**到操作句柄所对应的**完成事件队列**中。  

主动器为应用程序进程或线程提供事件循环，在循环中，主动器调用一个异步事件多路分发器（一个函数）**等待**完成事件的发生；当事件到达时，分发器返回，然后主动器将该事件**分发**给相应的完成处理程序，由处理程序处理异步操作的**结果**。  

需要定义一种传递异步操作结果的类型。需要传递的内容大致是操作结果是否成功、传递的字节数等。
与句柄关联的事件处理程序可以用对象或函数指针的方式（跟反应器差不多）。  
也跟反应器一样，分成两种策略：
* 单方法分配策略：只包含一个事件处理方法，主动起用该方法向相应的完成处理程序分配完成事件。这将会将发生的完成事件用参数的形式传递，这可以在不改变类接口的情况下增加新的事件处理流程，但是需要使用switch/if，这会降低扩展性。
* 多方法分配策略：跟反应器差不多，略。

在一个应用中可以使用**多个**完成处理程序、主动器和完成事件队列。比如可以将不同主动器应用到不同优先级的线程中，以提供不同的服务质量。  

整合这些完成处理信息的常用方法是异步完成标记模式。当请求异步操作时，可以向异步操作处理器传递一个异步完成标记，并由处理器保存起来供以后使用；当异步操作完成后，处理器找出预先保存的完成标记，并将它和这个完成事件插入到相应的完成事件队列，然后主动器分发这个事件给标记中指定的处理程序（可在O(1)内完成）。  

有些异步操作处理器允许取消异步操作，但是完成事件（取消事件）依然要产生。
主动器调用一个异步事件多路分发函数等待事件队列，一旦有事件，该函数就返回并进行事件分发。
多路分发策略有
* FIFO多路分发：按照插入队列的顺序处理
* 选择性分发：有选择的等待特定完成事件。

通常完成事件队列和异步事件多路分发器由系统提供，不需要自己编写。  

简单说就是，向主动器提交请求，当提交的任务做完后就执行与之关联的回调，当回调执行时表示操作已经完成。  
向主动器提交请求后，主动器将这个请求丢给异步处理器，然后在某个线程阻塞等待一个完成队列；当io执行完后异步处理器就向队列发完成事件，这样之前阻塞的函数便得到执行结果；得到结果后再配合异步标记获取执行方式执行回调。  



#### 扩展
当事件分发到处理程序后，处理程序只能处理耗时短的操作，以免降低应用程序整体响应能力。
可以把这些处理操作异步的执行，比如在Windows里可以丢到APC（异步过程调用，现在貌似已经不用了）里，等线程空闲或发生阻塞时，处理程序可以被运行。

可以创建一个线程池，用多线程方式处理比较好，Windows对完成端口进行了优化，确保在多线程等待事件时效率依然很高，并且使CPU的缓存相似性最大化。

可以用反应器来模拟主动器（asio中有相关代码），主要是用非阻塞io+反应器来模拟，以后写到相关内容再写。  


### 特点
事务分离、封装并发机制

### 缺点
如果操作系统不提供这类支持，需要使用多线程模拟主动器模式的语义。

---
## 异步完成标记/异步完成令牌（Asynchronous Completion Token）
主动多路分发。
### 作用
可以使应用程序有效地多路分发处理对调用服务的异步操作响应。
客户端在每个异步操作调用的同时传送一个标记，以包含其所需要的用于确定如何处理操作响应的最少信息。  
### 概念
ACT将每个异步操作调用和完成时需要客户端执行的特定行为联系起来，当客户端异步触发服务操作时，它还将ACT传递给该服务。服务在执行时保留但不修改标记，当操作完成，就将它和结果一起返回给客户端。客户端使用act来高效而明确地确定要执行的操作。

使用ACT来分发和处理异步操作结果，可以让客户端在常数时间内找到处理结果的方法和处理程序。
可以用内存地址做act的值，但是该地址如果被回收或重新分配了，会出现错误，所以使用指针做值会有风险。（好像可以用容器保存处理程序，再提供指针给act使用，这样不会有悬挂引用的情况发送，崩溃时也可以析构掉相关对象，asio好像就是这样的）
可以用代理标识（比如表中的索引）做值，通过它搜索处理程序进行处理。  


### 实现
将异步操作信息和处理完成事件的信息（能唯一标识完成处理程序，这个就是标记）一起提交，服务保存标记但不修改它，操作完成后将这些信息返回给用户，这样就可以直接用这些信息分发事件。

注意当接收到完成事件时，接收位置可能会处于另一个语境（线程或进程）。  

定义异步完成标记对服务是不透明的，但是对提交程序和完成处理程序应该是有意义的，有三种常用的表示法：
* 指针：用设计语言中结构的指针表示完成标记，在C++中用void*存储。
* 对象引用：可以将标记表示为在分布式对象计算中间件的对象引用。
* 索引：使用这个标记来查找表，得到相应的处理程序。可以使用一段数据中的偏移量（下标），这样就可以跨越多个进程使用。  

在启动程序中保存标记存在这些策略：
* 隐含：当使用指针标记的时候，这些对象会隐含的保存，这个方式时间空间效率很高，但是安全性和健壮性不好（服务停止后未处理的标记（对象指针）都在队列里）。
* 显式：用索引标记时，可在一个明确的数据结构中保存，这可以在崩溃时从数据表中找到相应的标记并释放对象。这能提高健壮性和安全性。  

如果不信任服务一定不会修改原先的标记，可在显式数据结构中存储额外信息来校验返回的标记是否被修改，但是这会带来一定的开销。  

无论采用哪种策略，在不再需要标记时，由启动程序（貌似指的是主动器，提交异步任务的东西）负责释放标记相关的资源。

启动程序可以用两种策略传递完成标记和异步请求：
* 隐含参数：存储在传递给服务的语境或环境中。
* 显式参数：作为参数传入

在执行服务时保存标记的策略：
* 如果服务是同步执行，可以简单的将标记留在运行时栈中。如果服务和启动程序在不同的线程或进程中，可以同步执行服务操作，但启动程序依然以异步设计模型设计。
* 如果服务异步执行操作，必须在数据结构中维持这个标记。

异步标记可用次数可以是多次，启动程序为每一个异步调用都设置同样的标记，这样可以使创建和销毁标记的开销最少。

异步完成事件分发策略有：
* 队列：从完成事件队列中获取完成标记。
* 回调：向服务传递一个回调函数或对象，完成时由服务或者服务代理调用回调。

#### 扩展
可以将标记传给同步操作，在同步操作执行完时也可以调用到回调，这样用于异步操作的代码也可以用于同步操作。

### 特点
高效的状态查询、空间效率高、灵活

### 缺点
当使用指针标记时可能会造成内存泄漏。

---
## 接受器-连接器（Acceptor-Connector）

### 作用
将网络中对等（Peer）事件处理程序 的连接和初始化同接下来进行的处理分离开。  
设立专门的对象（分发器）用于连接和接受连接，得到连接后由这个对象分发相应的连接句柄给注册的对象（接受器连接器）。  

可以使用同步或异步的连接建立策略，如果建立连接的延迟较小，可以用同步。  

### 概念
客户端服务处理程序可以通过调用本地连接器发起到远程服务处理程序的连接。它发送请求道相应的接收器，当建立连接后，就初始化相关的服务处理程序并将该连接传递给处理程序，然后处理程序利用这个连接互相合作，执行其应用功能。  
模式将连接的建立封装在单独的组件中，从而使服务处理程序不必关心底层网络机制的复杂性。此外，连接建立和初始化行为可以独立改变而不影响服务处理程序的功能。不过对于只连接到一个服务器并使用单一网络完成服务的简单应用来说，它可能会增加不必要的复杂性。  


### 实现
在对等体服务处理程序中封装应用服务。使用两个工厂（接受器、连接器）来初始化和连接对等服务。它们将两个对等服务和两个连接进行全关联，并且将每个传输端点封装到一个传输句柄中。  

接受器工厂在远程对等体的连接请求事件到达后被动的建立连接。连接器工厂主动地与指定的远程对等体服务建立连接。  

当完成连接后，接受器和连接器都会调用服务初始化流程初始化相应的对象，之后服务处理程序一般不需要与连接器和接受器工厂交互。  
分发器（Dispatcher）负责分发不同类型服务请求（连接、数据）的指示事件。分多个接受器可以注册同一个分配器，分配器替它们侦听来自对等体连接器的连接请求。连接器可向分发器注册以接收连接完成事件。

分发器可以按照反应器或主动器中的分发模式设计，也可以按照主动对象、领导者/追随者线程池将分发器实现为一个单独的线程或进程。

### 特点
可以实现异步高效地与大量主机主动地建立连接

### 缺点
增加了复杂性和间接性



<!--
# 需要补充的模式内容
_这本书后面带有很长的书单（附录C，参考文献），TODO 要看。_  

后面跟的编号代表出处（书）
**架构型**
对象同步器（Object Synchronizer，SPM99）

**设计模式**
抽象会话（Abstract Session）、命令处理器（Command Processor）、转发器-接收器（Forwarder-Receiver）、远程操作（Remote Operation，KTB98）、串行器（Serializer，RSB+97）、激活器（Activartor，Stal00）、客户端-分发器-服务器（Client-Dispatcher-Server）、驱逐器（Evictor，HV99）、定位器（Locator，JK00）、对象生命期管理器（Object Lifetime Manager，LGS99）、半对象加协议（Half Object Plus Protocol，Mes95）、管理者-代理人（Manager-Agent，KTB98）、事件通知（Event Notification，Rie96）、代码锁（Code Locking，McK95）、数据锁（Data Locking，McK95）、阅读器/记录器锁（Reader/Writer Locking，McK95）、特定通知（Specific Notification，Lea99a）、主-从（Master-Slave）、调度程序（Scheduler，Lea99a）、双阶段终止（Two-phase Termination，Grand98）
-->

---
title: "[模式] 并发型"
date: 2017-08-28 20:47:35
tags: 模式
categories: [学习笔记,模式]
description: 并发模式（还附加相关的一些其它模式）
---
_看的这本书的翻译不是很好（pdf比较旧，不知道有没有新的版本，书是好书，知识密度很大），都是直译，语序都不调，经常一个主语带一大串修饰语，看的时候还要把修饰语去掉才分得清什么是主语（有些还缺主语），总之看的很累，因为这本书相对比较复杂，看的时候还要花很多精力去分析语法和病句。_  
_感觉翻译这本书的人对这个翻译工作并不上心（可能是机翻，并且校对工作做得并不严谨）。例句（原句，不要怀疑我打错，书中比这更严重的错误到处都是）：为了将性能最大化，必须尽量减少引起与并发有关的开销的原因与（如语境切换、同步化和缓存一致性管理）。_  

_因为译文质量不行，所以笔记质量有所下降，不过依然尽量把大概的东西用自己的理解记下来，可能有误或遗漏（可能也没比书里好多少）。笔记里用到的一些术语是按照书里来的，个人感觉这些术语用得也不是很准确。_

# 同步模式
## 定界加锁（Scoped Locking）
c++惯用法，lock_guard相关，略。  

---
## 策略化加锁（Strategized Locking）
将锁作为策略传入，类似condition_variable中锁的用法。
可以在模板参数设置锁类型，这样锁可以随意替换，当不需要锁时传入null_mutex就可以取消掉锁的使用。
还可以用桥接的方式设置锁。

---
## 线程安全接口（Thread-Safe Interface）
使加锁开销减至最少，确保组件内部的方法调用不会因为要再次获得锁而自死锁。
就是为接口添加线程安全机制，略。  

---
## 双重检查加锁（Double-Checked Locking Optimization）
if-lock-if，可以先判断跳过加锁开销，多核情况需要注意用atomic，略。  

---
## 阻拦（Balking）/挂起保护（Guarded Suspension）  
锁的使用方式，内容较少合在一起
### 作用
Balking: 防止某些操作被重复执行，当对应操作正在执行时，其它线程如果调用到相应函数就直接放弃执行。  
Guarded Suspension: 跟上面一样，但是在操作正在执行时就阻塞等待，如果开发时知道等待时间可能会过长，就应该选择Balking模式。  
_感觉比较简单，因为这个好像是比较常见的操作，一不小心就用到了_

### 实现
Balking
其实就是加个flag，当一个线程进入函数时标记使其它线程进入时直接返回。  
用锁（需要try lock）或者原子操作都可以实现，比较简单这里不扩展例子。

Guarded Suspension
其实就是很常见的锁操作。



---
# 并发模式
## 主动对象（Active object）
并发对象。
使用异步方法调用（Asynchronous Method Invocation）实现

### 作用
将函数的调用和执行分离。  
其实就是将对象的函数弄成异步，这样在执行时便不会消耗等待函数执行完的时间，加强了并发性。    

### 实现
需要实现一个命令队列（可以是优先队列），和一个线程（该对象自己管理，可以换成线程池）等待队列的命令（操作该对象的命令），在执行完命令后还需要有一个机制（比如回调）取得操作的结果。  
用C#很容易用async/await实现，C++下如果有ppl也比较容易实现。  

用C#感觉没什么可写的（实现起来代码太少），这里直接用asio（因为有现成的命令队列用，这样就不占篇幅）：
```c++
// include略
using namespace std;
using namespace boost::asio;
class Num :
	public enable_shared_from_this<Num>
{
public:
	explicit Num(io_service& ios) :
		ios_(ios),
		num_(0)
	{
	}
	// 这里直接将操作委托给线程（池）做，从外面看来这个操作是透明的
	future<int> Add(int val)
	{
		auto pms = make_shared<promise<int>>();
		auto ret = pms->get_future();
		ios_.post([pms_ = move(pms), self = shared_from_this(), val]()
		{
			// 假设原本这个操作需要很久
			this_thread::sleep_for(chrono::seconds(1));
			pms_->set_value(self->num_.fetch_add(val) + val);
		});
		return ret;
	}
private:
	io_service& ios_;
	atomic<int> num_;
};

int main()
{
	io_service ios;
	io_service::work w(ios);
	// 可以放到线程池里，这里用单线程
	thread t([&]() {
		cout << "Begin" << endl;
		ios.run();
		cout << "End" << endl;
	});

	auto num = make_shared<Num>(ios);
	
	auto ret = num->Add(123);
	// 这里不会阻塞，可以执行其它代码
	// ...
	// 这里阻塞等待刚才的操作
	cout << ret.get() << endl;

	ios.stop();
	t.join();
	return 0;
}
```
按照这个理解asio的socket就是一种主动对象（可能有误）。  


---
## 监视器对象（Monitor Object）
线程安全的被动对象

### 作用
同步化并发方法的执行，以确保同一时刻在对象内部只有一个方法运行，它也可以调度方法的执行顺序使对象方法相互协调。  


### 实现
用户只能通过对象的同步方法来访问对象，这需要在对象内部包含锁，并将对象方法的访问同步化，以便一次仅有一个方法可以执行。
它提供一种机制，让线程在等待某个条件（阻塞）时不独占锁（需要用条件变量），这样其它线程就能访问这个对象（不会被阻塞）。  

其实就是一个同步对象，不过内部不需要有同步队列，而使用锁来使各个成员函数同步。因为没有自己的线程，所以处理时是被动的，所以叫做线程安全的被动对象。  

可以用条件变量、信号量等机制实现，简单，略。
注意当有可能发生嵌套调用时要换递归锁。


### 特点
简化并发控制和执行调度


---
## 半同步半异步（Half-Sync/Half-Async）
### 作用
将并发系统中的**同步和异步过程分离**，**简化编程又不影响性能**。


### 实现
引入两个通信层，一个处理**同步**服务，一个处理**异步**服务。还有一个**队列层**协调异步和同步层之间的通信。
在独立的线程或进程中**同步**地处理**高层**服务，以简化并发编程；**异步**地处理**底层**服务，以增强性能。如果同步异步之间需要**通信**或同步处理，则允许它们通过**队列**层向对方传递消息，队列层可以让同步层和异步层以“生产者/消费者”的方式交互。  

在处理同步时需要开发者无需考虑异步的复杂性，同时也不需要考虑同步的低效性；同步和异步要能互相通信，而不会使编程复杂化或过度地降低它们的性能。  

外部事件源（比如socket）产生被异步服务层接收和处理的事件，异步层处理后，通过队列层将结果传递给同步层中指定的服务。
简单来说就是异步层接收事件，然后传递给同步层处理。  
同步层一般用多线程或多进程实现。  
队列层对消息进行缓冲，这样同步和异步服务可以并发运行。缓冲消息时可以在消息过多时可以丢弃消息或者阻塞队列。
异步层中的服务**不能阻塞**，如果产生过多的消息，就需要丢弃消息，此时会使发送者等待超时并重新发送被取消的消息。  

注意这里的同步和异步指的是层，一个层中可以有多个服务实体，比如可以有多个异步服务向队列发信息，或者可以有多个同步服务取信息执行。

#### 扩展
反应器构成异步层可以实现半同步/半反应模式。

### 特点
事务分离

### 缺点
越过同步异步边界时会导致性能损失。  
可以让同步层和异步层之间共享内存区域，实现零拷贝。  


---
## 领导者/追随者（Leader/Followers）
### 作用
多个线程依次共享一组事件源，从而对源中产生的服务请求进行检测、分发和处理。

### 实现
为了将性能最大化，必须尽量减少与并发有关的开销（如上下文切换、同步和缓存一致性问题）。使用半同步/半反应时，在入队或出队消息队列时可能会导致大量的同步和上下文切换。  

简单来说就是多个线程轮流持有事件源，持有的就是领导者，其它线程就是追随者；追随者排队等待机会成为领导者。当领导者获得一个事件后，就将一个追随者提升为领导者，然后就去处理事件，处理完后就恢复到追随者的角色。这样多个线程可以并发地处理事件。  

这只需要在换事件源时进行同步。可以在接收事件时一次接多个，这样就可以降低交换次数。  
总体来说，这个模式比半同步/半反应模式有更高的性能，通过在线程间不交换数据来使加锁开销降低，并且在处理每个事件时不需要上下文切换。  



---
## 线程特定存储（Thread-Specific Storage）
线程本地存储
Thread-Local Storage

### 作用
tls，使每个线程中都持有一个相同声明的变量的副本。

### 实现
C++可直接用thread_local关键字，其它语言有各自的类库可用，比较简单，这里略

### 特点
使线程访问特定数据时不需要加锁

---
# 事件处理模式
这些模式有助于开发事件驱动应用程序。这些模式需要与并发模式相配合才能发挥最大作用。    
_注意可能之前已经会了一些东西，在看书时可能不会记之前会的知识，所以这里的内容可能会有一些遗漏_

---
## 反应器（Reactor）
反转了应用中的控制流。  
采用同步IO。  
EPOLL使用这个模式。

### 作用
多路分发并分配从一个或多个用户给应用的服务请求。

### 实现

不应该被单个指示事件阻塞而排斥其它的事件源，否则会降低响应能力。  
为了使吞吐率最大，应避免CPU之间不必要的切换、同步和数据移动。  
新的或改进的服务应该能很容易集成已有的多路分发和分配机制。  
应用程序代码应尽量不受多线程和同步机制的复杂性影响。  

为每一个服务（事件）引入一个单独的事件处理器，并在反应器中**注册**；反应器使用一个**同步**事件分发（分离）器**等待**一个或多个事件源的事件，当事件发生后，分发器**通知**反应器，反应器将事件**分配**到相应的事件处理器中处理；处理完成后处理器**返还**控制权。     

分发器是一个函数，调用该函数何以等待在一组句柄上的一个或多个指示事件，该函数阻塞直到有事件就绪（意味着可以对句柄进行相应的操作而不会阻塞）。

反应器定义了一个接口，允许用户注册或删除相应句柄的事件。内部需要维护一个多路分发表，需要处理句柄、事件处理程序、事件类型间的关系。

等待指示事件，多路分发事件给具体的事件处理程序，这些是反应器的责任而不是用户的责任，事件处理者并不调用反应器，而是由反应器分配一个具体事件给处理者处理。


在注册事件时，可以设置两类事件处理程序。  
* 对象：用对象作为分配目标，可以很方便派生子类事件处理程序，可以很容易在一个组件中集成服务的状态和方法。  
* 函数：不需要定义继承新的子类就可以很方便的注册回调函数。

可以用适配器的方式同时支持函数指针和对象，在对象里存储函数指针即可。

在使用事件处理对象时，有这些策略可以选择：
* 单方法分配接口策略：只包括一个事件处理方法，反应器用此方法分配事件，将事件的类型作为参数传递给方法。
    该策略要求在具体处理方法中用大量的switch/if来处理特定事件，会降低可扩展性。
* 多方法分配接口策略：为每一个事件创建一个单独的处理方法。这样可以很容易重载基类中的方法，但是需要模式的实现者预先知道事件类型。


在注册事件时，用于注册的方式可以有这些特征：

* 两个参数：一个参数指明处理程序，另一个表示事件类型。
* 三个参数：第三个参数传入句柄显式传入句柄，尽管更容易出错，但是它可以为多个句柄注册同一个处理程序，有助于节省内存占用。  


通常使用单例反应器，因为一个执行过程（进/线程）有一个反应器就够了，不过需要注意，有些系统在单个线程里能够使用的资源有限。
多线程中的多个事件处理流程是并行工作的，所以需要配合一些额外的同步机制。

简单来说就是向反应器注册相关事件，当事件可用时就可调用关联的操作，当事件到来时表示可执行某个操作。  



#### 扩展
可以用主动对象、领导者/追随者、半同步半异步模式并发处理具体事件。
一个反应器的定时器机制应该允许程序注册基于时间的具体事件处理程序，可以使用不同策略实现定时器机制，如堆、偏差表、定时轮。

### 特点
事务分离、模块化、粗粒度的并发控制

### 缺点
不能同时支持大量耗时长的客户机请求，因为它在事件多路分发层串行化了所有事件处理程序的处理过程。  

---
## 主动器（Proactor）
采用异步IO。  
IOCP使用这个模式。  
asio基于这个模式实现。  
更多相关内容见boost::asio的官方文档，那里记录了实现时需要的各个参与者。

### 作用
有效地多路分发和分配由完成的异步操作所触发的服务请求，在没有不利条件时，它可以获得并发的性能优势。

### 实现

为应用程序所提供的每个服务引入一个**异步操作**，由这些异步操作通过一个句柄和完成处理程序（回调）来主动地初始化对服务请求的处理（提交异步请求），完成处理程序处理包含这些异步操作结果的完成事件。


通常由系统内核实现异步操作处理器（异步IO由操作系统完成），当**异步操作执行完**后，异步操作处理器便产生相应的**完成事件**，并将完成事件**插入**到操作句柄所对应的**完成事件队列**中。  

主动器为应用程序进程或线程提供事件循环，在循环中，主动器调用一个异步事件多路分发器（一个函数）**等待**完成事件的发生；当事件到达时，分发器返回，然后主动器将该事件**分发**给相应的完成处理程序，由处理程序处理异步操作的**结果**。  

需要定义一种传递异步操作结果的类型。需要传递的内容大致是操作结果是否成功、传递的字节数等。
与句柄关联的事件处理程序可以用对象或函数指针的方式（跟反应器差不多）。  
也跟反应器一样，分成两种策略：
* 单方法分配策略：只包含一个事件处理方法，主动起用该方法向相应的完成处理程序分配完成事件。这将会将发生的完成事件用参数的形式传递，这可以在不改变类接口的情况下增加新的事件处理流程，但是需要使用switch/if，这会降低扩展性。
* 多方法分配策略：跟反应器差不多，略。

在一个应用中可以使用**多个**完成处理程序、主动器和完成事件队列。比如可以将不同主动器应用到不同优先级的线程中，以提供不同的服务质量。  

整合这些完成处理信息的常用方法是异步完成标记模式。当请求异步操作时，可以向异步操作处理器传递一个异步完成标记，并由处理器保存起来供以后使用；当异步操作完成后，处理器找出预先保存的完成标记，并将它和这个完成事件插入到相应的完成事件队列，然后主动器分发这个事件给标记中指定的处理程序（可在O(1)内完成）。  

有些异步操作处理器允许取消异步操作，但是完成事件（取消事件）依然要产生。
主动器调用一个异步事件多路分发函数等待事件队列，一旦有事件，该函数就返回并进行事件分发。
多路分发策略有
* FIFO多路分发：按照插入队列的顺序处理
* 选择性分发：有选择的等待特定完成事件。

通常完成事件队列和异步事件多路分发器由系统提供，不需要自己编写。  

简单说就是，向主动器提交请求，当提交的任务做完后就执行与之关联的回调，当回调执行时表示操作已经完成。  
向主动器提交请求后，主动器将这个请求丢给异步处理器，然后在某个线程阻塞等待一个完成队列；当io执行完后异步处理器就向队列发完成事件，这样之前阻塞的函数便得到执行结果；得到结果后再配合异步标记获取执行方式执行回调。  



#### 扩展
当事件分发到处理程序后，处理程序只能处理耗时短的操作，以免降低应用程序整体响应能力。
可以把这些处理操作异步的执行，比如在Windows里可以丢到APC（异步过程调用，现在貌似已经不用了）里，等线程空闲或发生阻塞时，处理程序可以被运行。

可以创建一个线程池，用多线程方式处理比较好，Windows对完成端口进行了优化，确保在多线程等待事件时效率依然很高，并且使CPU的缓存相似性最大化。

可以用反应器来模拟主动器（asio中有相关代码），主要是用非阻塞io+反应器来模拟，以后写到相关内容再写。  


### 特点
事务分离、封装并发机制

### 缺点
如果操作系统不提供这类支持，需要使用多线程模拟主动器模式的语义。

---
## 异步完成标记（Asynchronous Completion Token）
主动多路分发。
### 作用
可以使应用程序有效地多路分发处理对调用服务的异步操作响应。

### 实现
将异步操作信息和处理完成事件的信息（能唯一标识完成处理程序，这个就是标记）一起提交，服务保存标记但不修改它，操作完成后将这些信息返回给用户，这样就可以直接用这些信息分发事件。

注意当接收到完成事件时，接收位置可能会处于另一个语境（线程或进程）。  

定义异步完成标记对服务是不透明的，但是对提交程序和完成处理程序应该是有意义的，有三种常用的表示法：
* 指针：用设计语言中结构的指针表示完成标记，在C++中用void*存储。
* 对象引用：可以将标记表示为在分布式对象计算中间件的对象引用。
* 索引：使用这个标记来查找表，得到相应的处理程序。可以使用一段数据中的偏移量（下标），这样就可以跨越多个进程使用。  

在启动程序中保存标记存在这些策略：
* 隐含：当使用指针标记的时候，这些对象会隐含的保存，这个方式时间空间效率很高，但是安全性和健壮性不好（服务停止后未处理的标记（对象指针）都在队列里）。
* 显式：用索引标记时，可在一个明确的数据结构中保存，这可以在崩溃时从数据表中找到相应的标记并释放对象。这能提高健壮性和安全性。  

如果不信任服务一定不会修改原先的标记，可在显式数据结构中存储额外信息来校验返回的标记是否被修改，但是这会带来一定的开销。  

无论采用哪种策略，在不再需要标记时，由启动程序（貌似指的是主动器，提交异步任务的东西）负责释放标记相关的资源。

启动程序可以用两种策略传递完成标记和异步请求：
* 隐含参数：存储在传递给服务的语境或环境中。
* 显式参数：作为参数传入

在执行服务时保存标记的策略：
* 如果服务是同步执行，可以简单的将标记留在运行时栈中。如果服务和启动程序在不同的线程或进程中，可以同步执行服务操作，但启动程序依然以异步设计模型设计。
* 如果服务异步执行操作，必须在数据结构中维持这个标记。

异步标记可用次数可以是多次，启动程序为每一个异步调用都设置同样的标记，这样可以使创建和销毁标记的开销最少。

异步完成事件分发策略有：
* 队列：从完成事件队列中获取完成标记。
* 回调：向服务传递一个回调函数或对象，完成时由服务或者服务代理调用回调。

#### 扩展
可以将标记传给同步操作，在同步操作执行完时也可以调用到回调，这样用于异步操作的代码也可以用于同步操作。

### 特点
高效的状态查询、空间效率高、灵活

### 缺点
当使用指针标记时可能会造成内存泄漏。

---
## 接受器-连接器（Acceptor-Connector）

### 作用
将网络化系统中 对等体（Peer）服务 的连接和初始化工作 与 该工作 之后所执行的处理分开。 
设立专门的对象（分发器）用于连接和接受连接，得到连接后由这个对象分发相应的连接句柄给注册的对象（接受器连接器）。  

### 实现
在对等体服务处理程序中封装应用服务。使用两个工厂（接受器、连接器）来初始化和连接对等服务。它们将两个对等服务和两个连接进行全关联，并且将每个传输端点封装到一个传输句柄中。  

接受器工厂在远程对等体的连接请求事件到达后被动的建立连接。连接器工厂主动地与指定的远程对等体服务建立连接。  

当完成连接后，接受器和连接器都会调用服务初始化流程初始化相应的对象，之后服务处理程序一般不需要与连接器和接受器工厂交互。  
分发器（Dispatcher）负责分发不同类型服务请求（连接、数据）的指示事件。分多个接受器可以注册同一个分配器，分配器替它们侦听来自对等体连接器的连接请求。连接器可向分发器注册以接收连接完成事件。

分发器可以按照反应器或主动器中的分发模式设计，也可以按照主动对象、领导者/追随者线程池将分发器实现为一个单独的线程或进程。

### 特点
可以实现异步高效地与大量主机主动地建立连接

### 缺点
增加了复杂性和间接性

---
# 服务访问和配置模式
## 包装器外观（Wrapper Facade）
### 作用
把现有的非面向对象的API封装在更简洁的、可移植的、可维护的和内聚的面向对象接口里。  

### 实现
主要是需要考虑不同平台的同类型API的声明不同，需要加一些判断来处理（比如ifdef等条件编译，可以根据不同系统选择导入不同头文件），现在很多类库已经帮我们封装了，直接用就好。

### 缺点
相比直接调用，会有一些性能上的损失（一般可以忽略）。  

---
## 组件配置器（Component Configurator）
### 作用
允许应用程序在不必修改、重新编译或静态地重新链接的情况下，在运行时链接和解链接它的组件实现。还可以进一步支持在不关闭或重启进程的情况下，把组件重新配置到其它进程。    

### 实现
把这部分组件以某种方式打包（比如dll），在可以用一个组件管理器对象管理，一般要处理的管理操作有：初始化（载入）、结束（关闭组件并清除它的资源）、挂起（临时挂起组件执行）、恢复（恢复挂起）、通知（报告一些组件的信息比如挂起等状态）。

---
## 拦截器（Interceptor）
### 作用
允许透明地把服务加入框架，并且当事件发生时能自动触发服务。  

使用这个模式可以在不改变框架体系结构或者实现的情况下，增加、修改和删除服务。
### 实现
向某个实例注册服务请求拦截某个事件，在事件发生时就会检查注册的服务并执行。  
需要在程序中设置拦截点，通常是状态变化的间隙（或者是某个对象的构造函数、某个文件中的信息等）。当多个拦截器都注册到一个拦截点时，可以调整它们的优先级。  

perf的某些取样点可能就是拦截器的拦截点，通过向管理器注册需要在该位置取样就可以跟踪某些事件的执行次数；这些拦截点是编写代码时设置进去的。

### 缺点
会把设计变得复杂，某些拦截器阻塞时整个应用程序都会阻塞。
这时候可以将事件放队列里，在其它线程处理。

---
## 扩展接口（Extension Interface）
### 作用
允许组件导出多个接口，在扩展或修改现有组件的服务功能时，防止引起接口膨胀和客户机代码的破坏。  

设计稳定的接口是困难的，会遇到很多非预期的修改，如果不能处理这些改变，它将会破坏现有使用该组件的代码。
### 实现
为所有扩展接口设置一个根（父）接口（通常会定义getExtension方法），用户只能通过扩展接口访问组件提供的功能，当获得扩展接口的引用后，用户可以使用这个引用来获取该组件支持的其它扩展接口。  
给组件添加或修改功能后，导出扩展接口（可以通过继承原有接口进行扩展）而不是修改现有接口，并为每个组件类型引入工厂，将创建实例任务委托给工厂；工厂在创建组件得到根接口后，向根接口查询被请求的扩展接口，然后就可以使用扩展接口。  
需要使用整数或字符串或GUID命名（唯一）扩展接口方便查询。  

在扩展组件时，可以用多重继承、嵌套、独立接口类来处理功能上的扩展。

多重继承可以让组件继承它的所有扩展接口。  
嵌套类是在组件类内部实现扩展接口的类，组件类管理嵌套类的单例，当需要扩展接口时，就返回合适的嵌套类对象。
独立接口类就是用桥或适配器实现的独立于组件的类，当需要扩展接口时，就返回该类对象，并在该类内部存储组件引用。

可以用一个组件工厂发现者来管理组件工厂，发现者会维护组件类型和其工厂间的关联，用户向发现者提交组件的关键字信息，发现者就返回对应的组件工厂。  

<!--
# 需要补充的模式内容
_这本书后面带有很长的书单（附录C，参考文献），TODO 要看。_  

后面跟的编号代表出处（书）
**架构型**
对象同步器（Object Synchronizer，SPM99）

**设计模式**
抽象会话（Abstract Session）、命令处理器（Command Processor）、转发器-接收器（Forwarder-Receiver）、远程操作（Remote Operation，KTB98）、串行器（Serializer，RSB+97）、激活器（Activartor，Stal00）、客户端-分发器-服务器（Client-Dispatcher-Server）、驱逐器（Evictor，HV99）、定位器（Locator，JK00）、对象生命期管理器（Object Lifetime Manager，LGS99）、半对象加协议（Half Object Plus Protocol，Mes95）、管理者-代理人（Manager-Agent，KTB98）、事件通知（Event Notification，Rie96）、代码锁（Code Locking，McK95）、数据锁（Data Locking，McK95）、阅读器/记录器锁（Reader/Writer Locking，McK95）、特定通知（Specific Notification，Lea99a）、主-从（Master-Slave）、调度程序（Scheduler，Lea99a）、双阶段终止（Two-phase Termination，Grand98）
-->

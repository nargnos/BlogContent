---
title: "[模式] 划分、适配、扩展"
date: 2017-09-16 17:34:12
tags: 模式
categories: [学习笔记,模式]
description: 接口划分、组件划分、适配扩展
---
按照书里的分类，重复的内容只保留标题，表示它在这个分类内。

# 接口划分
## 显式接口（Explicit Interface）
### 作用
将组件的声明接口与其实现分开。将组件的接口导出给客户端，但是对客户端保持其实现的私有性和位置无关性。
_就是一般的接口用法_

## 扩展接口（Extension Interface）
设计稳定的接口是困难的，会遇到很多非预期的修改，如果不能处理这些改变，它将会破坏现有使用该组件的代码。   
### 作用
允许组件导出多个接口，在扩展或修改现有组件的服务功能时，防止引起接口膨胀和客户机代码的破坏。  

客户端只通过特化的扩展接口访问组件，当组件需要增加新功能或更新已有扩展接口声明的时候，都要引入新的扩展接口。
### 概念
为所有扩展接口设置一个根（父）接口（通常会定义getExtension方法），用户只能通过扩展接口访问组件提供的功能，当获得扩展接口的引用后，用户可以使用这个引用来获取该组件支持的其它扩展接口。  
给组件添加或修改功能后，导出扩展接口（可以通过继承原有接口进行扩展）而不是修改现有接口，并为每个组件类型引入工厂，将创建实例任务委托给工厂；工厂在创建组件得到根接口后，向根接口查询被请求的扩展接口，然后就可以使用扩展接口。  
需要使用整数或字符串或GUID命名（唯一）扩展接口方便查询。  

### 实现
在扩展组件时，可以用多重继承、嵌套、独立接口类来处理功能上的扩展。

多重继承可以让组件继承它的所有扩展接口。  
嵌套类是在组件类内部实现扩展接口的类，组件类管理嵌套类的单例，当需要扩展接口时，就返回合适的嵌套类对象。
独立接口类就是用桥或适配器实现的独立于组件的类，当需要扩展接口时，就返回该类对象，并在该类内部存储组件引用。

可以用一个组件工厂发现者来管理组件工厂，发现者会维护组件类型和其工厂间的关联，用户向发现者提交组件的关键字信息，发现者就返回对应的组件工厂。  

## 内省接口（Introspective Interface）
客户端要正确使用组件可能需要访问组件的某些信息，比如类型、标识、所支持接口或当前状态，但是允许客户端直接访问这些细节会破坏组件的封装，并降低稳定性。  
### 作用
不依赖实现细节的同时访问其内部机制。  
允许访问组件内部机制和结构信息，将反射接口和组件的“操作”接口分离。  

书中并没有详细描述实现方式，看图应该使导出相应的类型、名称等接口供用户读取。相关信息的获取需要语言（需要反射机制）或框架支持。

## 动态调用接口（Dynamic Invocation Interface）
### 作用
为允许客户端动态调用的组件引入一个调用接口，再运行时通过字符串来定位方法，而参数通过类型化的集合方式传递，将动态调用接口与组件的“操作”接口隔离开。  

这类调用可以用反射实现，但是会有一定开销，不过对于解释性语言来说不是太大问题。

## 代理（Proxy）
将代理模式扩展到分布式范围
### 作用
将所有组件的内务相关功能（比如授权）封装成一个单独的组件替代者，并让客户端只通过它进行通信，而不是直接访问组件本身。
### 概念
在设计时让它提供与组件相同的公共接口，当用户调用它的方法时，先在内部做预处理工作，然后再将请求转发给实际组件，在返回后将结果返回给用户。  



## 业务代表（Business Delegate）
理想情况下，客户端不应该关心其使用的组件是本地的还是远程的。
### 作用
为远程组件引入一个Business Delegate，它的创建、使用和销毁都跟本地组件一样，而且其接口与所代表的组件完全一致。由它完成所有网络任务，这对使用组件的客户端来说是透明的。  

### 概念
当客户端访问它时，它会**找到**其代表的远程组件，将方法调用转发给远程组件；另外它还负责通信时的错误处理；如果部署了组件的多个实例，他还可以再请求发送之前进行负载均衡；它还可以时系统管理功能的接入点，以监控所有客户端和远程组件的通信和交互。  

## 外观（Facade）
### 作用
为组件群指定一个单一访问点，在通常的使用场景中将客户端请求中转给合适的组件，同时也允许在特定的更复杂的情况下绕过该访问点。

### 概念
基本跟GoF的外观差不多，不过这里的组件可以是远程服务


## 组合方法（Combined Method）
感觉这个有点偏向重构技巧
### 作用
将组件中那些必须或通常一起执行的方法组合成一个方法。
就是把常常在一起执行的函数合并成一个函数，没什么可说的。

## 迭代器（Iterator）
略

## 枚举方法（Enumeration Method）
### 作用
将迭代放在聚合内部封装成一个枚举方法以负责完成遍历。将要在聚合的每个元素上执行的操作通过参数传递给枚举方法，再应用到每个元素上。

说人话就是，某些比较复杂的结构（比如树）不好写迭代器时，可以写一个访问函数，用回调的形式将对每个元素的操作传入函数中。

## 批处理方法（Batch Method)
### 作用
可以在聚合上执行大批访问，使用单独的批量方法在聚合上重复执行操作。该方法的声明接受每次执行操作所需的全部参数，结果也用类似的方式返回。
### 概念
这用在访问聚合时开销比较大的时候，比如查找多个元素，如果聚合在远程，那么多次遍历会造成很大的性能损失。
这时候将要执行的多个操作合并成一个请求发送，这在分布式系统中能显著提高性能。  
参考redis的pipeline比较容易理解。

# 组件划分
## 封装实现（Encapsulated Implementation）
就是一般的使用接口的方式，将实现细节隐藏在接口后面。

## 整体-部分（Whole-Part）
用于结构化分解
### 作用
有助于聚合组件形成一种语义单元。一种聚合组件（整体）封装其构成组件（部分），组织它们之间的协作，并为其功能提供一个公共接口，直接访问各个部分是不可能的。  
将组件对象看作一个整体，将其划分为多个独立的部分，使用整体进行封装，并定义一个接口，这个接口就是用户访问组件的唯一入口。  
### 概念
将各个部分（可以是同类型或不同类型对象）合并在一起，当作一个整体操作。  
操作时可以将操作通过计算分配给各个部分，也可以选择相关的部分进行操作。

比如ps中选择多个图层进行旋转缩放时就把各个部分（图层）看作是一个整体进行操作。

可以让多个整体共享同一个部分。
“整体”经常用外观或者中介者实现，“部分”则往往本身就是独立组件。可以使用访问者来处理“部分”的访问。

## 合成/组合（Composite）
略


## 主-从（Master-Slave）
### 作用
主控组件将工作分配给相同的从属组件并用从属组件返回的结果计算出最终结果。它支持容错性、并行计算以及计算准确性。
将服务划分成独立的可**并行执行**的子任务，通过合并这些子任务的返回结果来得到服务的最终结果。  

### 概念
其实就是分治法。用户用主控组件进行操控，而不需要知道分治细节。主控组件将工作划分为几个同等的子任务，并委派给从属组件处理，最后再处理返回的结果。

### 实现
可以并行执行任务；如果把多个同样的数据分配给从属组件，可以检测并处理失败的结果；如果任务被委派给多个不同的实现，可以检测并处理不精确的结果。
Master是组件的集中访问点。如果关注性能，它就需要划分足够多的任务；如果意图是提高精度或容错能力，可以让所有的Slave处理整个数据，然后通过比较来获得最终结果。  
只有一个Master会引入单点失败问题，可以使每个节点都为Master和Slave，通过指定具体实例来决定谁是Master谁是Slave。并可以使用心跳等机制来周期性通知所有Slave表示Master还存在，如果Master崩溃，其余Slave会推选出新Master。  

MS之间数据交互可以用数据对象封装，计算结果可以用future进行协调。

### 缺点
只有当相关服务可以分治的时候才可以应用，
如果子任务之间需要进行协调和同步，使用这个就不太合适。

## 半对象协议（Half-Object plus Protocol）
### 作用
在分布式系统中访问远程对象，由于跨网络交换和响应的时候会有延迟或抖动，这将使设计不能适应快速响应的需求。
可以将这些对象分成多个“半对象”，每个半对象只实现它所在地址空间内的客户端所要求的功能和数据，在所有半对象之间通过一个协议来帮助它们协调其动作，并保持其状态的一致性。  
### 概念
当调用组件上的某个服务时，如果半对象可以直接在客户端地址空间本地执行，就不需要通过网络，否则就通过网络获得必要信息。  

简单说就是把一个对象分成多个部分，将远程访问的服务跟本地的分开。  
这样就不需要通过网络交换整个对象。在本地执行的功能越多，交换数据量就越少，性能就越好；如果需要分布式计算的内容越多，交换的数据就越多。
所以应该尽量减少内部状态复制，从而减少通过协议进行数据交换的情况，但是这会使功能或数据重复。  

## 复制组件组（Replicated Component Group）
### 作用
保证组件的高可靠性和高容错性，提供**一组**组件的实现，将这些组件实现的复制件分布到不同的网络节点上。将客户端在组件上的请求转发给所有实现的实例，并等待其中的某个实例返回执行结果。  

### 概念
提升组件容错能力，只要组件的实例中至少有一个可以访问，客户端的请求就可以得到执行。这也可以提高可靠性，因为如果某些组件负载过重，其余的低负载对象仍可以完成请求。  

### 缺点
需要所有实例维护一致状态，这会引入大量的网络流量，而且会消耗大量的计算资源。

# 适配扩展
## 桥接（Bridge）
略

## 对象适配器（Object Adapter）
同适配器，略

## 责任链（Chain of Responsibility）
略

## 解释器（Interpreter）
略

## 拦截器/回调接口（Interceptor）
### 作用
允许透明地把服务加入框架，并且当事件发生时能自动触发服务。  
允许用户通过使用拦截器来注册额外服务扩展的方式对软件框架进行裁剪，当特定事件出现的时候框架将自动地触发这些扩展。  

使用这个模式可以在不改变框架体系结构或者实现的情况下，增加、修改和删除服务。
### 实现
向某个实例注册服务请求拦截某个事件，在事件发生时就会检查注册的服务并执行。  
需要在程序中设置拦截点，通常是状态变化的间隙（或者是某个对象的构造函数、某个文件中的信息等）。当多个拦截器都注册到一个拦截点时，可以调整它们的优先级。  


perf的某些取样点可能就是拦截器的拦截点，通过向管理器注册需要在该位置取样就可以跟踪某些事件的执行次数；这些拦截点是编写代码时设置进去的。
窗体的消息好像也类似这个，向框架注册在这个消息出现时执行某些操作。

### 缺点
会把设计变得复杂，某些拦截器阻塞时整个应用程序都会阻塞。
这时候可以将事件放队列里，在其它线程处理。

## 访问者（Visitor）
略

## 装饰器（Decorator）
略

## 执行-环绕对象（Execute-Around Object）
c++惯用法，类似raii；C#中要用可以让对象继承IDisposable然后用using。

## 模板方法（Template Method）
略

## 策略（Strategy）
略


## 空对象（Null Object）
### 作用
避免在程序中传递null。

### 实现
编写一个类，让它符合要求的接口，但是什么都不做，或者简单的返回默认值。
在函数执行失败时要么异常要么可以返回空，这样就需要显式的去测试这个返回值；但是有时候并不关心返回的东西是否为空（比如在链式访问时），这时可以返回一个空对象，函数跟正常返回的对象一样，只是不执行任何东西（函数体不写内容）。  

传递参数时也可以这么做，比如策略模式中，传递的策略可以是空对象，不做任何处理。在作为模板参数的时候，也可以使用空对象，比如可以自定义对象的锁类型，如果不需要锁，可以传入空对象让锁操作不执行任何语句。

空对象可以用单例来管理。

## 包装器外观（Wrapper Facade）
### 作用
把现有的非面向对象的API封装在更简洁的、可移植的、可维护的和内聚的面向对象接口里。  

### 实现
主要是需要考虑不同平台的同类型API的声明不同，需要加一些判断来处理（比如ifdef等条件编译，可以根据不同系统选择导入不同头文件），现在很多类库已经帮我们封装了，直接用就好。

### 缺点
相比直接调用，会有一些性能上的损失（一般可以忽略）。  

## 声明组件配置（Declarative Component Configuration）
### 作用
在不同的运行环境可能需要组件使用不同的服务或资源。
这个模式可以告诉运行时环境需要哪些资源和服务，以及组件会怎样使用这些资源和服务。
### 实现
就是写配置文件。
在部署的时候运行时环境根据规范自我配置。


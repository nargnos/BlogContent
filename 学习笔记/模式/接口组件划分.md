---
title: "[模式] 接口、组件划分"
date: 2017-09-16 17:34:12
tags: 模式
categories: [学习笔记,模式]
description: 接口划分、组件划分，还有一些服务访问和配置相关
---
<!--12 13 18-->
# 服务访问和配置模式
## 包装器外观（Wrapper Facade）
### 作用
把现有的非面向对象的API封装在更简洁的、可移植的、可维护的和内聚的面向对象接口里。  

### 实现
主要是需要考虑不同平台的同类型API的声明不同，需要加一些判断来处理（比如ifdef等条件编译，可以根据不同系统选择导入不同头文件），现在很多类库已经帮我们封装了，直接用就好。

### 缺点
相比直接调用，会有一些性能上的损失（一般可以忽略）。  

---
## 组件配置器（Component Configurator）
### 作用
允许应用程序在不必修改、重新编译或静态地重新链接的情况下，在运行时链接和解链接它的组件实现。还可以进一步支持在不关闭或重启进程的情况下，把组件重新配置到其它进程。    

### 实现
把这部分组件以某种方式打包（比如dll），在可以用一个组件管理器对象管理，一般要处理的管理操作有：初始化（载入）、结束（关闭组件并清除它的资源）、挂起（临时挂起组件执行）、恢复（恢复挂起）、通知（报告一些组件的信息比如挂起等状态）。

---
## 拦截器（Interceptor）
### 作用
允许透明地把服务加入框架，并且当事件发生时能自动触发服务。  

使用这个模式可以在不改变框架体系结构或者实现的情况下，增加、修改和删除服务。
### 实现
向某个实例注册服务请求拦截某个事件，在事件发生时就会检查注册的服务并执行。  
需要在程序中设置拦截点，通常是状态变化的间隙（或者是某个对象的构造函数、某个文件中的信息等）。当多个拦截器都注册到一个拦截点时，可以调整它们的优先级。  

perf的某些取样点可能就是拦截器的拦截点，通过向管理器注册需要在该位置取样就可以跟踪某些事件的执行次数；这些拦截点是编写代码时设置进去的。

### 缺点
会把设计变得复杂，某些拦截器阻塞时整个应用程序都会阻塞。
这时候可以将事件放队列里，在其它线程处理。

---


# 接口划分
## 显式接口（Explicit Interface）
### 作用
将组件的声明接口与其实现分开。将组件的接口导出给客户端，但是对客户端保持其实现的私有性和位置无关性。
_就是一般的接口用法_

## 扩展接口（Extension Interface）
设计稳定的接口是困难的，会遇到很多非预期的修改，如果不能处理这些改变，它将会破坏现有使用该组件的代码。   
### 作用
允许组件导出多个接口，在扩展或修改现有组件的服务功能时，防止引起接口膨胀和客户机代码的破坏。  

客户端只通过特化的扩展接口访问组件，当组件需要增加新功能或更新已有扩展接口声明的时候，都要引入新的扩展接口。
### 概念
为所有扩展接口设置一个根（父）接口（通常会定义getExtension方法），用户只能通过扩展接口访问组件提供的功能，当获得扩展接口的引用后，用户可以使用这个引用来获取该组件支持的其它扩展接口。  
给组件添加或修改功能后，导出扩展接口（可以通过继承原有接口进行扩展）而不是修改现有接口，并为每个组件类型引入工厂，将创建实例任务委托给工厂；工厂在创建组件得到根接口后，向根接口查询被请求的扩展接口，然后就可以使用扩展接口。  
需要使用整数或字符串或GUID命名（唯一）扩展接口方便查询。  

### 实现
在扩展组件时，可以用多重继承、嵌套、独立接口类来处理功能上的扩展。

多重继承可以让组件继承它的所有扩展接口。  
嵌套类是在组件类内部实现扩展接口的类，组件类管理嵌套类的单例，当需要扩展接口时，就返回合适的嵌套类对象。
独立接口类就是用桥或适配器实现的独立于组件的类，当需要扩展接口时，就返回该类对象，并在该类内部存储组件引用。

可以用一个组件工厂发现者来管理组件工厂，发现者会维护组件类型和其工厂间的关联，用户向发现者提交组件的关键字信息，发现者就返回对应的组件工厂。  

## 内省接口（Introspective Interface）
客户端要正确使用组件可能需要访问组件的某些信息，比如类型、标识、所支持接口或当前状态，但是允许客户端直接访问这些细节会破坏组件的封装，并降低稳定性。  
### 作用
不依赖实现细节的同时访问其内部机制。  
允许访问组件内部机制和结构信息，将反射接口和组件的“操作”接口分离。  

书中并没有详细描述实现方式，看图应该使导出相应的类型、名称等接口供用户读取。相关信息的获取需要语言（需要反射机制）或框架支持。

## 动态调用接口（Dynamic Invocation Interface）
### 作用
为允许客户端动态调用的组件引入一个调用接口，再运行时通过字符串来定位方法，而参数通过类型化的集合方式传递，将动态调用接口与组件的“操作”接口隔离开。  

这类调用可以用反射实现，但是会有一定开销，不过对于解释性语言来说不是太大问题。

## 代理（Proxy）
将代理模式扩展到分布式范围
### 作用
将所有组件的内务相关功能（比如授权）封装成一个单独的组件替代者，并让客户端只通过它进行通信，而不是直接访问组件本身。
### 概念
在设计时让它提供与组件相同的公共接口，当用户调用它的方法时，先在内部做预处理工作，然后再将请求转发给实际组件，在返回后将结果返回给用户。  



## 事务委托（Business Delegate）
理想情况下，客户端不应该关心其使用的组件是本地的还是远程的。
### 作用
为远程组件引入一个Business Delegate，它的创建、使用和销毁都跟本地组件一样，而且其接口与所代表的组件完全一致。由它完成所有网络任务，这对使用组件的客户端来说是透明的。  

### 概念
当客户端访问它时，它会**找到**其代表的远程组件，将方法调用转发给远程组件；另外它还负责通信时的错误处理；如果部署了组件的多个实例，他还可以再请求发送之前进行负载均衡；它还可以时系统管理功能的接入点，以监控所有客户端和远程组件的通信和交互。  

## 外观（Facade）
### 作用
为组件群指定一个单一访问点，在通常的使用场景中将客户端请求中转给合适的组件，同时也允许在特定的更复杂的情况下绕过该访问点。

### 概念
基本跟GoF的外观差不多，不过这里的组件可以是远程服务


## 组合方法（Combined Method）
感觉这个有点偏向重构技巧
### 作用
将组件中那些必须或通常一起执行的方法组合成一个方法。
就是把常常在一起执行的函数合并成一个函数，没什么可说的。

## 迭代器（Iterator）
略

## 枚举方法（Enumeration Method）
### 作用
将迭代放在聚合内部封装成一个枚举方法以负责完成遍历。将要在聚合的每个元素上执行的操作通过参数传递给枚举方法，再应用到每个元素上。

说人话就是，某些比较复杂的结构（比如树）不好写迭代器时，可以写一个访问函数，用回调的形式将对每个元素的操作传入函数中。

## 批量方法（Batch Method)
### 作用
可以在聚合上执行大批访问，使用单独的批量方法在聚合上重复执行操作。该方法的声明接受每次执行操作所需的全部参数，结果也用类似的方式返回。
### 概念
这用在访问聚合时开销比较大的时候，比如查找多个元素，如果聚合在远程，那么多次遍历会造成很大的性能损失。
这时候将要执行的多个操作合并成一个请求发送，这在分布式系统中能显著提高性能。  
参考redis的pipeline比较容易理解。

# 组件划分
## 封装实现（Encapsulated Implementation）
就是一般的使用接口的方式，将实现细节隐藏在接口后面。

## 整体-部分（Whole-Part）
用于结构化分解
### 作用
有助于聚合组件形成一种语义单元。一种聚合组件（整体）封装其构成组件（部分），组织它们之间的协作，并为其功能提供一个公共接口，直接访问各个部分是不可能的。  
将组件对象看作一个整体，将其划分为多个独立的部分，使用整体进行封装，并定义一个接口，这个接口就是用户访问组件的唯一入口。  
### 概念
将各个部分（可以是同类型或不同类型对象）合并在一起，当作一个整体操作。  
操作时可以将操作通过计算分配给各个部分，也可以选择相关的部分进行操作。

比如ps中选择多个图层进行旋转缩放时就把各个部分（图层）看作是一个整体进行操作。

可以让多个整体共享同一个部分。
“整体”经常用外观或者中介者实现，“部分”则往往本身就是独立组件。可以使用访问者来处理“部分”的访问。

## 合成（Composite）
略


## 主-从（Master-Slave）
### 作用
主控组件将工作分配给相同的从属组件并用从属组件返回的结果计算出最终结果。它支持容错性、并行计算以及计算准确性。
将服务划分成独立的可**并行执行**的子任务，通过合并这些子任务的返回结果来得到服务的最终结果。  

### 概念
其实就是分治法。用户用主控组件进行操控，而不需要知道分治细节。主控组件将工作划分为几个同等的子任务，并委派给从属组件处理，最后再处理返回的结果。

### 实现
可以并行执行任务；如果把多个同样的数据分配给从属组件，可以检测并处理失败的结果；如果任务被委派给多个不同的实现，可以检测并处理不精确的结果。
Master是组件的集中访问点。如果关注性能，它就需要划分足够多的任务；如果意图是提高精度或容错能力，可以让所有的Slave处理整个数据，然后通过比较来获得最终结果。  
只有一个Master会引入单点失败问题，可以使每个节点都为Master和Slave，通过指定具体实例来决定谁是Master谁是Slave。并可以使用心跳等机制来周期性通知所有Slave表示Master还存在，如果Master崩溃，其余Slave会推选出新Master。  

MS之间数据交互可以用数据对象封装，计算结果可以用future进行协调。

### 缺点
只有当相关服务可以分治的时候才可以应用，
如果子任务之间需要进行协调和同步，使用这个就不太合适。

<!--## Half-Object plus Protocol-->



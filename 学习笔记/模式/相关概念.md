---
title: "[模式] 相关概念"
date: 2017-08-25 16:43:24
tags: 模式
categories: [学习笔记,模式]
description: 设计模式原则、分类等
---

# 设计模式原则
**单一职责**
    不能让一个类有多个修改的原因。
    一个类只做一件事和仅有一个引起变化（指的是职责变化）的原因。只做一件事，保证了类的细粒度和高内聚，这样有利于对象重用。

**开闭原则**
    程序在不修改原先程序的情况下完成扩展。
    对扩展是开放的，对修改是封闭的。

**里氏替换LSP**
    父类方法在子类中不能被修改，子类型(subtype)必须能够替换它们的基类型。
    子类型能替代父类型，但是不能让调用父类型的代码在行为上有改变。  

**依赖倒置**
    一个对象若要调用另一个对象，应该依赖于该对象的抽象类型，而不是具体实现。
    高层模块不应该依赖低层模块，二者都应该依赖抽象。如果高层模块直接以来低层模块，在低层模块发生变动时会影响到高层模块。  
    抽象不应该依赖细节，细节应该依赖抽象。细节属于低层，抽象属于高层。  

**接口隔离**
    细粒度接口。
    细粒度接口能够保持接口的稳定。

# 分类
注意这里是GoF模式的分类。

**创建型模式**
单例模式、工厂（工厂方法）模式、抽象工厂模式、建造者（生成器）模式、原型模式。

**结构型模式**
适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。

**行为型模式**
模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、
解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。

# 其它
**设计模式主要是为了封装变化**。它可以封装对象创建、结构和行为上的变化。  

在程序设计时一般都要遵循分层设计，表现层与业务层分成不同模块，抽象与具体隔离。  
为了解耦，设计模式操作或生成的对象**一般都是抽象**的。

各个模式之间其实并没有明确的互斥关系，也就是说，可以从各个模式里取长补短来修补自身模式中有缺陷的部分，模式在各个情境中会有不同的实现方式。  

在某些有反射机制的语言里，可以配合配置文件设置不同的具体对象，用反射创建这些类型。  

**依赖注入**
形式分为三种：构造函数注入、设置方法注入、接口注入。  
用于控制反转（IoC）容器。如果构造函数参数或成员、属性的类型是抽象接口类型，那么具体依赖的源头就在于具体对象的创建，将创建具体对象的职责转移到IoC容器，就可以在运行时给对应对象传递依赖。  

**惯例优于配置**
比如根据对象的命名规则来判断相应类型，不过这只有在支持反射的语言里才能用。  
---
title: "[模式] 资源、数据"
date: 2017-09-13 21:03:14
tags: 模式
categories: [学习笔记,模式]
description: 资源管理模式
---
_这里有一部分内容之前已经写过，不再重复。另外看的这本书翻译正确多了，看得好舒服。_
<!--20 21-->
# 资源获取
## 查找（Lookup）
### 作用
使用查找服务作为中介实例来发现和访问资源（不管资源是本地的还是分布的）。
### 概念
提供一个资源**查找服务**，可以向它注册（描述和引用）**资源提供者**或**资源**，这样在**资源使用者**使用到资源时，查找服务可以访问提供者获取资源或直接返回注册的资源；使用者不需要知道提供者的位置，提供者也不需要知道使用者的位置。  
### 实现
1. 决定查找服务的接口
2. 决定是注册资源引用还是资源提供者引用
3. 实现查找服务
    可以用map来存储
4. 提供查找服务访问点
    可以是一个指针或引用，也可以是主机地址。如果查找服务没有发布访问点，可以用一个自举协议来获得访问点，就是当查找服务收到资源提供者或使用者的初始请求后，就回应访问点，这样的协议通常需要广播或多播协议来设计。  
5. 决定查询语言
    可以让使用者用复杂的方式寻找资源。  

### 扩展
资源提供者和资源可以合并。  
可以设置一个单独的实体负责把引用注册到查找服务，而不必在提供者实现。  
可以将多个查找服务联合起来，在自身无法执行请求时将它转发给其它服务，这样可以扩展查询范围。  
查找服务可以用来建立容错系统，复制查找服务或复制资源及其资源提供者可以实现。  
### 特点
可获得性、自举、位置独立、配置简单。
基于属性来选择资源，可以细粒度地匹配用户需求。  
### 缺点
悬挂引用，资源提供者失效后，查找服务的引用会变得过时。  
单一失败点，服务崩溃后需要等待其重启重新注册资源，另外可能会成为性能瓶颈，所以需要复制查找服务。
相同资源可能会错误的重复注册，需要在实现中注意确保属性唯一。

---
## 延迟获取（Lazy Acquisition）
延迟初始化是这个模式的一个特化，之前写过了。  
这里不同的是获取的是资源，某些资源不一定是对象（不需要初始化），获取时可以返回一个代理对象，等到用到的时候通过代理对象获取资源，获取步骤对调用者是透明的。  
还可以扩展为延迟载入模块（比如dll），或延迟求值等

---
## 预先获取（Eager Acquisition）
### 作用
在实际使用资源前预先获取并初始化资源来使运行时资源获取具有可预测性和快速性。
### 概念
在使用之前，**资源提供者代理**已经从**资源提供者**那里先获取了**资源**，然后资源被保存在高效的容器中。当资源提供者代理获取**资源使用者**的资源请求时，就可以通过访问容器来返回请求的资源。  
内存池就是用这个模式。  
### 特点
提升性能
### 缺点
需要管理获取的资源，并且可能出现过度获取的情况，如果一开始获取了过多资源，会减慢启动速度

---
## 部分获取（Partial Acquisition）
### 作用
把资源获取分成多阶段来优化资源管理，每个阶段都获取资源的一部分。  
### 概念
之前提到过，不过说的不是资源。  
在获取资源时，可以根据当前的系统状况或根据某些策略分步获取一定数目的资源，当资源被部分获取时，使用者就可以开始使用它。  
注意在分步获取时可能有一些额外的调用开销。

---
# 资源生命周期
## 缓存（Caching）
之前写过了。
实现时缓存对象的提供者和存储者可以不是同一个对象。  
另外可以配合一些资源获取模式使用，让获取缓存这个行为透明。  

---
## 池（Pooling）
### 作用
通过循环使用不再需要的资源来避免昂贵的获取和释放资源的开销，一旦资源被循环利用并置入池中，它们就失去了自己的标识和状态。  
### 概念
在池中管理一类资源的多个实例，被释放的资源会被放回池中。  
为了增加效率，资源池会在创建后预先获取固定数目的资源，如果对资源的需求超过了池中的资源数目，它会延迟地获取更多资源。
当**资源**被释放并放回池中时，**资源使用者**或者**资源池**应当让资源失去其标识；资源被重用前，它需要重新初始化，可以提供一个单独的初始化接口。
资源使用者只依赖于资源池以及实际的资源，资源由资源池从**资源提供者**（通常是系统）获取。
### 扩展
可以用来管理线程和连接。  
连接池可以维持远程服务的连接，这样在请求服务时直接使用该连接发送请求。  

### 特点
提升性能、共享资源、稳定可伸缩
### 缺点
管理资源会有一些额外开销，需要注意同步问题

---
## 协调者（Coordinator）
### 作用
协调多个参与者（每个参与者都包含资源、资源使用者和资源提供者）的任务的完成来维护系统的一致性。  
使得在涉及多个参与者的任务中，要么所有参与者的任务都完成，要么一项任务都没有完成；这确保了系统总是处于一致的状态。  
### 概念
比如由分布在网络上多个处理节点的大规模系统，每个节点上的子系统的服务需要被频繁更新。为了让它们能够动态更新，每个节点都需要由一个软件下载组件。为了更新整个系统的配置，需要有一个集中监管组件来和每个节点上的下载组件通信。集中监管组件需要向多个下载组件发送更新请求，如果有部分下载组件未能更新系统，那么就会导致系统处于不一致的状态。  
所以需要这个模式来协调同一个任务的多个参与者，任务被分配到多个参与者，每个参与者都独立工作，每个参与者执行的工作都必须成功，以达成整个任务的成功。  

可以引入**协调者**，负责所有**参与者**执行和完成**任务**。所有参与者执行的工作都分成两个阶段：准备和提交。  
在准备阶段，协调者要求每个参与者准备要完成的工作。每个参与者必须用这个阶段类检查一致性并判断结果是否会失败。如果在准备阶段有参与者返回失败，协调者就停止任务，并且要求完成准备的参与者中止任务并恢复为开始前的状态。  
如果参与者全都成功完成了准备，协调者就发起参与者的提交操作，参与者会在这个阶段做实际的工作，因为准备阶段表明工作会成功，所以提交阶段会成功，整个任务便可成功执行。  
### 特点
原子性、一致性
### 缺点
额外的开销和职责

---
## 资源生命周期管理器（Resource Lifecycle Manager）
### 作用
将资源的生命周期管理和它们的使用解耦。  
### 概念
如果程序管理对象复杂的生命周期，其复杂性可能会影响到程序的核心功能，使得业务逻辑难以维护，因为它们的代码纠缠在一起。  
这里的资源可以是网络连接、线程、同步原语、服务等，引入RLM可以管理和维护资源使用者用到的资源。  

资源使用者可以用RLM来获取和访问特定的资源。如果被请求的资源不存在，RLM会执行创建工作。  
RLM知道当前的资源使用情况，所以可以拒绝来自资源使用者的资源获取请求。比如内存很少的时候它可以拒绝分配内存。  
它还管理这些资源的回收，并基于当前可用资源来选择合适的策略维护资源。  
它可以负责一类或多类资源，如果资源之间存在依赖关系，它们之间可协同工作。

当使用者使用资源时从RLM获取资源，不使用时还回去。可用池或者缓存模式来优化它。

### 特点
提升效率和性能
### 缺点
出错会导致程序的很多部分运行失败

---
# 资源释放
## 租约（Leasing）
### 作用
通过在获取资源时把资源和基于时间的租约相关联，从而简化资源的释放。  
在租约过期并且没有被更新时，资源就会被自动释放。  
### 概念
配合前面的一些模式（比如查找服务）使用的，暂存的资源可能再也不会被访问到（可能是引用失效，或者是不被使用），如果不清除会造成堆积。  
当资源使用者和资源在不同的分布式节点的时候可能会出现这种情况。  

为每个被资源使用者使用的**资源**引入一个**租约**，**授与者**（通常是资源提供者）提供租约，**持有者**（通常是资源使用者）获得租约。租约表明资源使用者可以使用资源的时间长度。  
如果使用者持有资源，到期时就会被使用者释放；如果使用者持有的是资源的引用，到期时就由提供者释放，其引用就标记为无效。  
在未过期时可以取消或者延长租约。  

### 扩展
可以设置到期时自动更新的租约，在过期时自动更新；或者设置回调在过期时提醒是否续约。

### 特点
可以使资源版本相对容易的被新版本替换。  
增强系统稳定性。
### 缺点
额外开销、额外逻辑、需要定时监视器

---
## 清除者（Evictor）
### 作用
可以让我们决定何时以及如何释放资源以优化资源管理，并且可以配置不同的策略来自动决定哪些资源应该释放，以及应该什么时候释放。  
### 概念
程序中会用到各种资源，在设置缓存或池的时候并不知道这些资源的使用频率。有可能一些资源只用一次，但是程序持续获取它们并且不释放它，这就会导致性能下降和系统不稳定；如果在使用资源之后立刻释放，程序可能又需要重新使用相同资源，这会造成一定性能损耗。  

可以监控**资源**的使用，用某种**清除策略**（LRU最近最少使用（淘汰最长时间未被使用）、LFU最近最不常用（淘汰一定时间访问次数最少））来控制其生命周期。当资源被**资源使用者**使用时，就会被程序标记，然后**清除者**周期性的根据需要选择没有被标记的资源释放掉。  
还可以制定其它策略比如按内存大小，优先清除占内存大的资源。  

### 扩展
可以在清除资源时将资源放入FIFO队列，这样队列满时，前面的就被清除；如果其中的元素又被访问了，就取出使用，避免了重新创建资源的开销，但是会有维护队列的开销。  
可以配合池来使用，当清除时放入池中，如果池满了就删除对象。

### 特点
低内存占用、稳定
### 缺点
额外开销，策略不适合时会造成资源重新获取
